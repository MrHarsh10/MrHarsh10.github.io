{"meta":{"title":"Mr Harsh的技术笔记","subtitle":"广阔天地，大有作为。","description":"The Quieter You Are, The More You Hear","author":"Mr Harsh","url":"http://www.helicunzai.cn","root":"/"},"pages":[{"title":"关于","date":"2023-05-02T08:43:56.499Z","updated":"2022-10-30T13:38:18.955Z","comments":false,"path":"about/index.html","permalink":"http://www.helicunzai.cn/about/index.html","excerpt":"","text":"我们将在没有黑暗的地方相会 所有的生活都是合理的,我们没必要相互理解。"},{"title":"404 Not Found：该页无法显示","date":"2023-06-02T14:52:36.281Z","updated":"2022-08-10T08:07:27.912Z","comments":false,"path":"/404.html","permalink":"http://www.helicunzai.cn/404.html","excerpt":"","text":""},{"title":"分类","date":"2023-05-02T08:43:56.499Z","updated":"2022-08-08T14:44:28.266Z","comments":false,"path":"categories/index.html","permalink":"http://www.helicunzai.cn/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-07-09T08:00:35.577Z","updated":"2023-07-09T08:00:35.577Z","comments":true,"path":"admin/index.html","permalink":"http://www.helicunzai.cn/admin/index.html","excerpt":"","text":"登录 #app{ text-align: center; } 欢迎登陆后台"},{"title":"标签","date":"2023-05-02T08:43:56.830Z","updated":"2022-08-08T14:45:01.893Z","comments":false,"path":"tags/index.html","permalink":"http://www.helicunzai.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"微型计算机系统笔记","slug":"微型计算机系统笔记","date":"2023-07-16T03:28:47.000Z","updated":"2023-07-16T03:43:27.901Z","comments":true,"path":"2023/07/16/微型计算机系统笔记/","link":"","permalink":"http://www.helicunzai.cn/2023/07/16/%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/","excerpt":"","text":"微机系统","categories":[{"name":"微机原理与接口技术","slug":"微机原理与接口技术","permalink":"http://www.helicunzai.cn/categories/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"微机原理与接口技术","slug":"微机原理与接口技术","permalink":"http://www.helicunzai.cn/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/"}]},{"title":"MATLAB学习整理","slug":"MATLAB学习整理","date":"2023-07-08T02:15:34.000Z","updated":"2023-07-08T02:15:34.172Z","comments":true,"path":"2023/07/08/MATLAB学习整理/","link":"","permalink":"http://www.helicunzai.cn/2023/07/08/MATLAB%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"STM32标准库：实现流水灯","slug":"STM32标准库：实现流水灯","date":"2023-07-03T14:00:32.000Z","updated":"2023-07-16T03:58:56.791Z","comments":true,"path":"2023/07/03/STM32标准库：实现流水灯/","link":"","permalink":"http://www.helicunzai.cn/2023/07/03/STM32%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%B5%81%E6%B0%B4%E7%81%AF/","excerpt":"","text":"123456789101112131415161718#include &quot;stm32f10x.h&quot; // Device header#include &quot;delay.h&quot;int main()&#123; uint16_t i=0; GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.GPIO_Mode=GPIO_Mode_Out_PP; GPIO_InitStruct.GPIO_Speed=GPIO_Speed_50MHz; GPIO_InitStruct.GPIO_Pin=GPIO_Pin_All; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); GPIO_Init(GPIOA,&amp;GPIO_InitStruct); while(1)&#123; for(i=0;i&lt;8;i++)&#123; GPIO_Write(GPIOA,~(0X0001&lt;&lt;i)); Delay_s(1); &#125; &#125;&#125;","categories":[{"name":"STM32","slug":"STM32","permalink":"http://www.helicunzai.cn/categories/STM32/"}],"tags":[{"name":"STM32","slug":"STM32","permalink":"http://www.helicunzai.cn/tags/STM32/"}]},{"title":"STM32:新建库函数工程","slug":"STM32-新建库函数工程","date":"2023-07-03T03:18:07.000Z","updated":"2023-07-03T05:54:57.318Z","comments":true,"path":"2023/07/03/STM32-新建库函数工程/","link":"","permalink":"http://www.helicunzai.cn/2023/07/03/STM32-%E6%96%B0%E5%BB%BA%E5%BA%93%E5%87%BD%E6%95%B0%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"建立STM32_FW文件夹 获取ST公司提供的STM32固件库en.stsw-stm32054.zip,得到文件夹STM32F10x_StdPeriph_Lib_V3.5.0。新建文件夹，命名为STM32_FW,在该文件夹下新建7个文件夹，分别命名为boot,cmsis,library,user,obj,list,interrupt. 负责粘贴 STM32F10x_StdPeriph_Lib_V3.5.0下STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\DeviceSupport\\ST\\STM32F10x\\startup\\arm找到8个文件 将上面7个文件复制到boot目录下。此为STM32的启动文件，是汇编语言格式，每个STM32必须有启动文件。 STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\DeviceSupport\\ST\\STM32F10x下找到 这3个文件，以及STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\CoreSupport下 两个文件，将这5个文件复制到STM32_FW下cmsis目录中，此为STM32的BSP文件，负责基本的内核及外设初始化。 复制STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\STM32F10x_StdPeriph_Driver下inc和src到STM32_FW的library中，这两个文件夹为STM32的固件函数库文件。 复制STM32F10x_StdPeriph_Lib_V3.5.0\\Project\\STM32F10x_StdPeriph_Template下 到STM32_FW的interrupt中，此为STM32在MDK下的中断服务入口函数。 复制STM32F10x_StdPeriph_Lib_V3.5.0\\Project\\STM32F10x_StdPeriph_Template下stm32f10x_conf.h到STM32_FW到user目录下。 在STM32_FW下user中新建main.c 执行完后就得到如下目录结构。 STM32_FW\\boot目录：startup_stm32f10x_cl.s、startup_stm32f10x_hd.s、 startup_stm32f10x_hd_vl.s、startup_stm32f10x_ld.s、startup_stm32f10x_ld_ vl.s、startup_stm32f10x_md.s、startup_stm32f10x_md_vl.s、startup_ stm32f10x_xl.s STM32_FW\\interrupt目录：STM32f10x_it.h、STM32f10x_it.c STM32_FW\\cmsis目录：core_cm3.c、core_cm3.h、stm32f10x.h、system_ stm32f10x.c、system_stm32f10x.h STM32_FW\\user目录：main.c、stm32f10x_conf.h STM32_FW\\library目录：inc、src文件夹 STM32_FW\\list目录：空 STM32FW\\obj目录：空 建立工程 新建一个文件夹，放本次工程文件，如proj,将STM32_FW的文件夹全部复制到改文件夹目录下。 打开keil,选择Project-&gt;New uVision Project, 保存后，选择芯片类型，取消添加STM32的Stertup code 在项目管理目录窗口下点击Manage Projects items,将Target重命名为Proj,并删除Source Group 1,在级联菜单选择Add Group,将boot,cmsis,library,interrupt,user添加进去。","categories":[{"name":"STM32","slug":"STM32","permalink":"http://www.helicunzai.cn/categories/STM32/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://www.helicunzai.cn/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"STM32","slug":"STM32","permalink":"http://www.helicunzai.cn/tags/STM32/"}]},{"title":"ES6:字符串的拓展","slug":"ES6-字符串的拓展","date":"2023-04-01T03:07:35.000Z","updated":"2023-04-01T03:20:51.099Z","comments":true,"path":"2023/04/01/ES6-字符串的拓展/","link":"","permalink":"http://www.helicunzai.cn/2023/04/01/ES6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%93%E5%B1%95/","excerpt":"","text":"方法 说明 includes(B,index) 是否包含某个字符串 startsWith(B,index) 是否以某个字符串开头 endsWith(B,index) 是否以某个字符串结尾 repeat(n) 对某个字符串进行重复 trim() 去除首尾空格 trimStart() 去除开头的空格 trimEnd() 去除结尾的空格 padStart(len,str) 在开头进行填充 padEnd() 在结尾进行填充 模板字符串 123let a=&quot;hello world&quot;; let b=`$&#123;a&#125;`+&quot;!!!!&quot;; console.log(b);","categories":[{"name":"ES6","slug":"ES6","permalink":"http://www.helicunzai.cn/categories/ES6/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.helicunzai.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"ES6","slug":"ES6","permalink":"http://www.helicunzai.cn/tags/ES6/"}]},{"title":"CSS选择器","slug":"CSS选择器","date":"2023-03-26T09:05:36.000Z","updated":"2023-03-26T15:57:30.183Z","comments":true,"path":"2023/03/26/CSS选择器/","link":"","permalink":"http://www.helicunzai.cn/2023/03/26/CSS%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"","text":"CSS3选择器的分类 基础选择器 层次选择器 伪类选择器 伪元素选择器 属性选择器 基础选择器 选择器 类型 * 通配选择器 E 标签选择器 #id ID选择器 .class 类选择器 selector1,selectorN 群组选择器 层次选择器 选择器 类型 X Y 后代选择器 X &gt; Y 子选择器 X + Y 相邻兄弟选择器 X ~ Y 通用兄弟选择器 伪类选择器 动态伪类选择器 选择器 类型 E:link 超链接伪类选择器 E:visted 超链接伪类选择器 E:active 用户行为伪类选择器 E:hover 用户行为伪类选择器 E:focus 用户行为伪类选择器 目标伪类选择器 123#about:target&#123;&#125; 语言伪类选择器 123E:lang(en)&#123;&#125; UI元素状态伪类选择器 选择器 类型 E:checked 选中状态伪类选择器 E:checked 启用状态伪类选择器 E:disabled 不可用状态伪类选择器 结构伪类选择器 选择器 功能描述 E:first-child 匹配父元素中包含的第一个名称为E的子元素，与E:nth-child(1)相同 E:last-child 匹配父元素中包含的最后一个名称为E的子元素，与E:nth-last-child(1)相同 E:root 选择匹配元素E所在文档的根元素 E F:nth-child 选择父元素E中所包含的第n个子元素F，其中n可以是整数(1、2、3)、关键字（even、odd）,也可以是公式（2n+1,-n+） E F:nth-last-child 选择父元素E中所包含的倒数第n个子元素F E:nth-of-type(n) 选择父元素中所包含的具有指定类型的第n个E元素 E:nth-last-of-type(n) 选择父元素中所包含的具有指定类型的倒数第n个元素 E:first-of-type 选择父元素中所包含的具体指定类型的第一个E元素，与E:nth-of-type(1)等同 E:last-of-type 选择父元素中所包含的具有指定类型的最后一个E元素，与E:nth-last-of-type(1)等同 E:only-child 选择父元素中所包含的唯一一个子元素E E:only-of-type 选择父元素中所包含的唯一一个同类型的同级兄弟元素E E:empty 选择不包含任何子元素的E元素，并且该元素也不包含任何文本节点 否定伪类选择器 123E:not(F)&#123; &#125; 伪元素 ::first-letter ::first-line ::before和::after ::selection 属性选择器 选择器 功能描述 E[attr] 选择匹配具有属性attr的E元素 E[attr=val] 选择匹配具有属性attr的E元素，并且attr的属性值为val E[attr|=val] 选择匹配E元素，并且E元素定义了属性attr,attr属性值是一个具有val或者val-开始的属性值。 E[attr~=val] 选择匹配E元素，并且E元素定义了属性attr,attr属性值具有多个空格分隔的值 E[attr*=val] 选择匹配E元素，并且E元素定义了属性attr,其属性值任意位置包含了val E[attr^=val] 选择匹配E元素，并且E元素定义了属性attr,其属性是以val开头的任意字符串 E[attr$=val] 选择匹配E元素，并且E元素定义了属性attr,其属性值是以val结尾的任意字符串","categories":[{"name":"前端","slug":"前端","permalink":"http://www.helicunzai.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://www.helicunzai.cn/tags/CSS/"},{"name":"前端","slug":"前端","permalink":"http://www.helicunzai.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"学习Vue:第三天","slug":"学习Vue-第三天","date":"2023-03-14T01:43:12.000Z","updated":"2023-03-15T05:48:25.573Z","comments":true,"path":"2023/03/14/学习Vue-第三天/","link":"","permalink":"http://www.helicunzai.cn/2023/03/14/%E5%AD%A6%E4%B9%A0Vue-%E7%AC%AC%E4%B8%89%E5%A4%A9/","excerpt":"","text":"事件处理 123456789101112131415161718192021&lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;button v-on:click=&quot;showInfo(name)&quot;&gt;点击&lt;/button&gt; &lt;button @click=&quot;showInfo(name)&quot;&gt;点击&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const vm=new Vue(&#123; el:&#x27;#demo&#x27;, data:&#123; name:&quot;Mars&quot;, &#125;, methods:&#123; showInfo(a)&#123; alert(a) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 事件修饰符 1 Vue中的事件修饰符 prevent：阻止默认事件 stop：阻止事件冒泡 onece：事件只触发一次 capture：使用事件的捕获模式 self：只有self.target是当前操作的元素才触发事件 passive：事件的默认行为立即执行，无需等待事件回调执行完毕","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.helicunzai.cn/categories/Vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.helicunzai.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://www.helicunzai.cn/tags/Vue/"}]},{"title":"学习Vue:第二天","slug":"学习Vue-第二天","date":"2023-03-11T07:28:25.000Z","updated":"2023-03-11T08:17:08.896Z","comments":true,"path":"2023/03/11/学习Vue-第二天/","link":"","permalink":"http://www.helicunzai.cn/2023/03/11/%E5%AD%A6%E4%B9%A0Vue-%E7%AC%AC%E4%BA%8C%E5%A4%A9/","excerpt":"","text":"Object.defineProperty 12345678910&lt;script&gt; let person =&#123; name:&quot;张三&quot;, age:18 &#125; Object.defineProperty(person, &quot;sex&quot;,&#123; value:&quot;男&quot;, &#125;) console.log(person)&lt;/script&gt; 无法枚举 enumerable配置项 1234567891011&lt;script&gt; let person =&#123; name:&quot;张三&quot;, age:18 &#125; Object.defineProperty(person, &quot;sex&quot;,&#123; value:&quot;男&quot;, enumerable:true, &#125;) console.log(person)&lt;/script&gt; writable配置项 123456789101112&lt;script&gt; let person =&#123; name:&quot;张三&quot;, age:18 &#125; Object.defineProperty(person, &quot;sex&quot;,&#123; value:&quot;男&quot;, enumerable:true, writable:true &#125;) console.log(person)&lt;/script&gt; configurable配置项 12345678910111213&lt;script&gt; let person =&#123; name:&quot;张三&quot;, age:18 &#125; Object.defineProperty(person, &quot;sex&quot;,&#123; value:&quot;男&quot;, enumerable:true, writable:true, configurable:true, &#125;) console.log(person)&lt;/script&gt; get配置项 12345678910111213&lt;script&gt; let person =&#123; name:&quot;张三&quot;, age:18 &#125; let number=&quot;男&quot; Object.defineProperty(person, &quot;sex&quot;,&#123; get:function()&#123; return number &#125; &#125;) console.log(person)&lt;/script&gt; set配置项 1234567891011121314151617&lt;script&gt; let person =&#123; name:&quot;张三&quot;, age:18 &#125; let number=&quot;男&quot; Object.defineProperty(person, &quot;sex&quot;,&#123; get:function()&#123; return number &#125;, set:function(value)&#123; console.log(&quot;sex change&quot;+value) number = value &#125; &#125;) console.log(person)&lt;/script&gt; 数据代理 123456789101112&lt;script&gt; let obj=&#123;x:100&#125; let obj2=&#123;y:100&#125; Object.defineProperty(obj2,&#x27;x&#x27;,&#123; get()&#123; return obj.x &#125;, set(value)&#123; obj.x=value&#125; &#125;)&lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.helicunzai.cn/categories/Vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.helicunzai.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://www.helicunzai.cn/tags/Vue/"}]},{"title":"学习Vue:第一天","slug":"学习Vue-第一天","date":"2023-03-05T08:40:47.000Z","updated":"2023-03-11T07:24:27.202Z","comments":true,"path":"2023/03/05/学习Vue-第一天/","link":"","permalink":"http://www.helicunzai.cn/2023/03/05/%E5%AD%A6%E4%B9%A0Vue-%E7%AC%AC%E4%B8%80%E5%A4%A9/","excerpt":"","text":"hello案例 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;你好哇,&#123;&#123;name.toUpperCase()&#125;&#125;&lt;/h1&gt; &lt;h1&gt;Age:&#123;&#123;age&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;Date.now().toString()&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; //创建Vue实例 const x=new Vue(&#123; el:&quot;#demo&quot;, data:&#123; name: &quot;刘鹤&quot;, age:18 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;/script&gt;&lt;/body&gt;&lt;/html&gt; 插值语法: 123&lt;h1&gt;你好哇,&#123;&#123;name.toUpperCase()&#125;&#125;&lt;/h1&gt;&lt;h1&gt;Age:&#123;&#123;age&#125;&#125;&lt;/h1&gt;&lt;h1&gt;&#123;&#123;Date.now().toString()&#125;&#125;&lt;/h1&gt; 指令语法:v-bind 1234567&lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;插值语法&lt;/h1&gt; &lt;h2&gt;你好哇,&#123;&#123;name.toUpperCase()&#125;&#125;&lt;/h2&gt; &lt;h1&gt;指令语法&lt;/h1&gt; &lt;h2&gt;&lt;a v-bind:href=&quot;url&quot;&gt;超链接&lt;/a&gt;&lt;/h2&gt; &lt;h2&gt;&lt;a :href=&quot;url2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;/div&gt; 汇总 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;插值语法&lt;/h1&gt; &lt;h2&gt;你好哇,&#123;&#123;name.toUpperCase()&#125;&#125;&lt;/h2&gt; &lt;h1&gt;指令语法&lt;/h1&gt; &lt;h2&gt;&lt;a v-bind:href=&quot;urls.url1&quot;&gt;超链接&lt;/a&gt;&lt;/h2&gt; &lt;h2&gt;&lt;a :href=&quot;urls.url2.toLowerCase()&quot;&gt;超链接2&lt;/a&gt;&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; //创建Vue实例 const x=new Vue(&#123; el:&quot;#demo&quot;, data:&#123; name: &quot;WORLD&quot;, age:18, urls:&#123; url1:&quot;http://helicunzai.cn&quot;, url2:&quot;HTTPS://www.helicunzai.CN&quot;, &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 数据绑定 单向数据绑定 1234&lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;单向数据绑定&lt;/h1&gt; &lt;input type=&quot;text&quot; v-bind:value=&quot;name.toUpperCase()&quot;&gt;&lt;/div&gt; 双向数据据绑定 只能用于表单类元素 1234567&lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;单向数据绑定&lt;/h1&gt; &lt;input type=&quot;text&quot; v-bind:value=&quot;name.toUpperCase()&quot;&gt; &lt;h1&gt;双向数据绑定&lt;/h1&gt;&lt;hr&gt; &lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;/div&gt;/div&gt; MVVM模型 M:模型（model），对应data中的数据。 V:视图(view),模板。 VM:视图模型（view model）,Vue中实例对象。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://www.helicunzai.cn/categories/Vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://www.helicunzai.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://www.helicunzai.cn/tags/Vue/"}]},{"title":"GCC编译器","slug":"GCC编译器","date":"2023-03-02T08:31:31.000Z","updated":"2023-03-02T09:00:18.674Z","comments":true,"path":"2023/03/02/GCC编译器/","link":"","permalink":"http://www.helicunzai.cn/2023/03/02/GCC%E7%BC%96%E8%AF%91%E5%99%A8/","excerpt":"","text":"第一次实验 编辑器下输入 12345#include &quot;stdio.h&quot;int main()&#123; printf(&quot;Welcome&quot;); return 0;&#125; 然后在终端中输入 1gcc test.c 生成a.out。如果加入选项-o进行 1gcc test.c -o out 后使用 1./out GCC选项 GCC最基本的用法是： gcc [options] [filenames] 其中options就是编译器所需的参数，filename给出相关的文件名称。 -c,只编译，不链接成为可执行文件，编译器只是由输出的.c等源代码文件生成的.o成为后缀的目标文件，通常用于编译不包含主程序的子程序文件。 -o output_filename,确定输出文件的名称为output_filename,同时这个名称不能和源文件同名。如果不给出这个选项，GCC就给出预设的可执行文件a.out。 -g，产生符号调试工具所必要的符号资讯，要想对源代码进行调试，就必须加入该选项。 -O,对程序进行优化编译、链接，采用这个选项，整个源代码会在编译，链接过程中进行优化处理，这样产生的可执行文件的执行效率可以提高，但是编译、链接的速度就相应地要慢一些。 -O2，比-O更好的优化编译、链接，但是整个编译、链接过程会更慢。 警告 GCC包含完整的出错检查和警告提示功能。","categories":[{"name":"编译器","slug":"编译器","permalink":"http://www.helicunzai.cn/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"}],"tags":[{"name":"GCC","slug":"GCC","permalink":"http://www.helicunzai.cn/tags/GCC/"}]},{"title":"VIM的使用","slug":"VIM的使用","date":"2023-01-29T15:44:58.000Z","updated":"2023-01-30T07:53:16.688Z","comments":true,"path":"2023/01/29/VIM的使用/","link":"","permalink":"http://www.helicunzai.cn/2023/01/29/VIM%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"VIM的基本模式 1.一般模式 一进入VIM就是处于一般模式（命令模式），该模式下只能输入指令，不能输入文字。这些指令可能是让光标移动的指令，也可能是删除指令或取代指令。 2.编辑模式 输入&quot;i&quot;就会进入编辑模式（插入模式），此时在状态列会有INSERT字样。在该模式下才可以输入文字，按Esc键又会回到命令模式 3.底行模式 输入 :就会进入底行模式，此时坐下角会有一个冒号，等待输入命令。按Esc键就可以返回命令模式。 VIM的基本操作 VIM的命令行模式操作 1.进入插入模式 i:光标前插入在光标左侧输入正文。 I:在光标所在行的开头输入正文。 a:光标后插入在光标右侧输入正文。 A:在光标所在行的末尾输入正文。 o:在光标所在行的下一行增添新行。 O:在光标所在行的上一行增添新行。 2.移动光标 hjkl:左、下、上、右。 Ctrl+B:在文件中向上移动一页（相当于PageUp键） Ctrl+F:在文件中向下移动一页（相当于PageDown键） G:移到文件最后。 H:将光标移动到屏幕最上行(Highest) nH:将光标移到屏幕的第n行。 M:将光标移到屏幕的中间。 L:将光标移到屏幕的最下行。 nL:将光标移动到屏幕的倒数第n行。 w:在指定行内右移光标，到下一个字的开头。 e:在指定行内右移光标，到下一个字的末尾。 b:在指定行内左移光标，到前一个字的开头。 0：左移光标，到本行的开头。 $:右移光标，到本行的末尾。、 ^:移动光标，到本行的第一个非空字符。 3.删除 x:删除光标所指的当前的字符 nx:删除光标所指的前n个字符 :1,#d:删除行1至行#的文字 X:删除光标前面一个字符。 D：删除至行尾 dw:删除光标右侧的字。 ndw:删除光标右侧的n个字。 db:删除光标左侧的字。 ndb:删除光标左侧的n个字。 dd:删除光标所在行。 ndd:删除n行内容。 4.更改 cw:更改光标处之字到此一单词之字尾处。 c#w:如c3w表示更改3个单词。 cc:修改行。 5.取代 r:取代光标处之字符 R:取代字符直到按Esc键为止。 6.复制和粘贴 yw:复制光标之字到字尾至缓存区。 yy:复制光标所在之行至缓存区。 #yy:如5yy，复制光标所在之处以下5行至缓冲区。 P:把缓冲区的资料粘贴在所在行之后。 p:把缓冲区的资料粘贴在所在行之前。 7.撤销 u:undo,复原至上一动作。 8.重复上一个命令 .: :重复上一个命令 VIM的底行模式的操作 1.退出命令 :wq或:x，先保存再退出VIM。 :w 或:w filename :保存/保存为filename名的文件。 :q :退出 :q!或:quit :不保存退出VIM。 :wq! :强制保存,并退出。 2.显示和取消行号 :set nu:显示行号。 :set nonu:不显示行号。 3.字符搜索 :/str :正向搜索 :?str :反向搜索 :/str/ w file :正向搜索，并将第一个包含字符串str的行写入file文件 :/str1,/str2/w file :正向搜索，并将包含字符串str1的行至包含字符串str2的行写入file文件 4.删除正文 :d :删除光标所在行 :3 d ：删除3行 :.,$ d ：删除当前行至正文的末尾 :/str1/,str2/d :删除从字符串str1到str2的所有行。 5.恢复文件 :recover :恢复文件","categories":[{"name":"VIM","slug":"VIM","permalink":"http://www.helicunzai.cn/categories/VIM/"}],"tags":[{"name":"VIM","slug":"VIM","permalink":"http://www.helicunzai.cn/tags/VIM/"}]},{"title":"jQuery整理","slug":"jQuery整理","date":"2022-12-29T03:41:46.000Z","updated":"2023-01-29T15:45:14.309Z","comments":true,"path":"2022/12/29/jQuery整理/","link":"","permalink":"http://www.helicunzai.cn/2022/12/29/jQuery%E6%95%B4%E7%90%86/","excerpt":"","text":"jQuery导入 CDN地址 12&lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt; 12&lt;script src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt; jQuery语法 jQuery是通过选取HTML元素然后进行某些操作。 1$(selector).action() 如： $(&quot;p.test&quot;).hide() 文档就绪事件 所有 jQuery 函数位于一个 document ready 函数中 123$(document).ready(function()&#123; // jQuery 代码...&#125;); 也可以 123$(function()&#123; // jQuery 代码...&#125;); jQuery选择器 jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。 元素选择器 1$(&quot;p&quot;)//选取所有&lt;p&gt; 元素 id选择器 1$(&quot;#test&quot;) class选择器 1$(&quot;.test&quot;) 其他选择器 语法 描述 $(“*”) 选取所有元素 $(this) $(this) $(“p.intro”) 选取 class 为 intro 的 元素 $(“p:first”) 选取第一个 元素 $(“ul li:first”) 选取第一个 元素的第一个 元素 $(“ul li:first-child”) 选取每个 元素的第一个 元素 $(“[href]”) $(“[href]”) $(“a[target=‘_blank’]”) $(“a[target=‘_blank’]”) $(“a[target=‘_blank’]”) 选取所有 target 属性值不等于 “_blank” 的 元素 $(“:button”) 选取所有 type=“button” 的 元素 和 元素 $(“tr:even”) 选取偶数位置的 元素 $(“tr:odd”) 选取奇数位置的 元素 jQuery事件 常见DOM事件 鼠标事件 键盘事件 表单事件 文档/窗口事件 click keypress submit submit dblclick keydown change resize mouseenter keydown focus scroll mouseleave blur unload hover jQuery 事件方法语法 1$(&quot;p&quot;).click(); 123$(&quot;p&quot;).click(function()&#123; // 动作触发后执行的代码!!&#125;); jQuery 效果 隐藏和显示 1234567$(&quot;#hide&quot;).click(function()&#123; $(&quot;p&quot;).hide();&#125;);$(&quot;#show&quot;).click(function()&#123; $(&quot;p&quot;).show();&#125;); 123$(&quot;button&quot;).click(function()&#123; $(&quot;p&quot;).toggle();&#125;); 淡入淡出 fadeIn() 方法 1$(selector).fadeIn(speed,callback); fadeOut() 方法 1$(selector).fadeOut(speed,callback); fadeToggle() 方法 1$(selector).fadeToggle(speed,callback); fadeTo() 方法 1$(selector).fadeTo(speed,opacity,callback); 滑动 slideDown() 方法 1$(selector).slideDown(speed,callback) slideUp() 方法 1$(selector).slideUp(speed,callback); slideToggle() 方法 1$(selector).slideToggle(speed,callback); 动画 1$(selector).animate(&#123;params&#125;,speed,callback); 停止动画 1$(selector).stop(stopAll,goToEnd); 获取内容和属性 获得内容 - text()、html() 以及 val() text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标签） val() - 设置或返回表单字段的值 attr()- 用于获取属性值。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.helicunzai.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.helicunzai.cn/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://www.helicunzai.cn/tags/jQuery/"}]},{"title":"Springboot:第一个项目","slug":"Springboot-第一个项目","date":"2022-12-17T08:49:38.000Z","updated":"2022-12-31T07:40:51.999Z","comments":true,"path":"2022/12/17/Springboot-第一个项目/","link":"","permalink":"http://www.helicunzai.cn/2022/12/17/Springboot-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"IDEA专业版创建项目 项目结构 Spring Boot的基础结构有3个主要目录 src/main/java:程序开发以及主程序目录 src/main/resourse:配置文件和资源文件目录 src/test/java:测试程序目录 建议目录 java根目录 Application.java:建议放在根目录下，是项目的启动类 comm:建议放置公共类，如全局的配置文件、工具类 models:主要用于实体(Entity) repository:主要是数据库访问层代码 service:主要是业务类代码 resources目录 static:存在Web访问的静态资源，如JS、CSS、图片 templates:存放项目页面 appplication.properties:存放项目配置信息 pom.xml详解 Spring Boot项目根目录下的pom.xml是Maven项目中非常重要的配置文件，主要描述项目包的依赖和项目构建时的配置。 项目的描述信息 123456&lt;groupId&gt;com.example&lt;/groupId&gt;&lt;artifactId&gt;demo&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packageing&gt;jar&lt;/packageing&gt;&lt;name&gt;demo&lt;/name&gt;&lt;description&gt;demo&lt;/description&gt; groupId:项目的包路径 artifactId:项目名称 version:项目版本号 packageing:一般有jar、war两个值 name:项目名称 description：项目描述 项目的依赖配置信息 1234567891011121314151617181920212223242526&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;demo&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; parent:配置父级项目的信息。Maven支持项目的父子结构，引入后会默认继承父级的配置。 depencies:配置项目所需的依赖包，SpringBoot体系内的依赖组件不需要填写版本号，spring-boot-starter-parent维护了体系内所有依赖包的版本信息 构建时需要的公共变量 123&lt;properties&gt; &lt;java.version&gt;17&lt;/java.version&gt;&lt;/properties&gt; 构建配置 此部分为构建配置，这里使用Maven构建Springboot,所以必须在&lt;plugins&gt;中添加spring-boot-maven-plugin插件，它能够使Maven的方式为应用SpringBoot支持。 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 上面配置spring-boot-maven-plugin构建插件，将springboot应用打包为可执行的Jar或War文件，然后以简单的方式运行Springboot应用。 第一个helloworld程序 我们在controller下创建HelloController.java 1234567891011package com.example.demo.controller;import org.springframework.web.bind.annotation.*;@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/&quot;) public String hello()&#123; return &quot;hello springframework&quot;; &#125;&#125; 单元测试 单元测试在日常项目开发中必不可少，Springboot提供了完善的单元测试框架和工具用于测试开发的应用。 Spring Boot集成单元测试 单元测试主要用于测试单个代码组件 引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 创建单元测试 在src/test目录下新建一个HelloTest类。 12345678910111213package com.example.demo;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestclass DemoApplicationTests &#123; @Test void contextLoads() &#123; System.out.println(&quot;hello&quot;); &#125;&#125; 运行单元测试 测试Service方法 创建Service测试类 一般使用Spring Boot进行单元测试主要针对Service和API进行。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.helicunzai.cn/categories/SpringBoot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.helicunzai.cn/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.helicunzai.cn/tags/SpringBoot/"}]},{"title":"Linux C:内存管理","slug":"Linux-内存管理","date":"2022-11-25T00:41:51.000Z","updated":"2022-11-25T01:16:54.363Z","comments":true,"path":"2022/11/25/Linux-内存管理/","link":"","permalink":"http://www.helicunzai.cn/2022/11/25/Linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"动态内存和静态内存 动态内存和静态内存分配方式不同 静态内存是在程序编译时候完成的，动态内存是在运行的 静态内存是在栈上分配的，而动态内存是在堆上分配的 内存管理基本操作 分配内存 malloc()函数 void *malloc(unsigned int size) 123long *buffer;buffer=(long*)malloc(500*sizeof(long));free(buffer); realloc()函数 void *realloc(void *men_address,unsigned int newsize) 调整men_address所指的内存区域大小为newsize长度 1234char *p;p=(char*)malloc(100*sizeof(char));p=(char*)realloc(p,200*sizeof(char));free(p); calloc()函数 分配n个长度为size的内存快 123char *p;p=(char*)calloc(200,sizeof(char));free(p); memset()函数 void *memset(void *s,char ch,unsigned nn) 设置s中所有的字节为ch,s的大小为n 12345char s[]=&quot;hello world\\n&quot;;printf(&quot;%s&quot;,s);memset(s+6,&#x27;*&#x27;,5);printf(&quot;%s&quot;,s);return 0; 释放内存 free()函数 void free(void *memblock) 要释放的内存快","categories":[{"name":"C","slug":"C","permalink":"http://www.helicunzai.cn/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://www.helicunzai.cn/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://www.helicunzai.cn/tags/Linux/"}]},{"title":"Java:输入/输出","slug":"Java-输入-输出","date":"2022-11-22T08:54:56.000Z","updated":"2022-11-22T08:56:37.177Z","comments":true,"path":"2022/11/22/Java-输入-输出/","link":"","permalink":"http://www.helicunzai.cn/2022/11/22/Java-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"http://www.helicunzai.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.helicunzai.cn/tags/Java/"}]},{"title":"Java:线程","slug":"Java-线程","date":"2022-11-22T08:54:39.000Z","updated":"2022-11-22T08:56:17.067Z","comments":true,"path":"2022/11/22/Java-线程/","link":"","permalink":"http://www.helicunzai.cn/2022/11/22/Java-%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"http://www.helicunzai.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.helicunzai.cn/tags/Java/"}]},{"title":"Java:泛型与集合类","slug":"Java-泛型与集合类","date":"2022-11-22T08:54:31.000Z","updated":"2022-11-22T08:55:52.678Z","comments":true,"path":"2022/11/22/Java-泛型与集合类/","link":"","permalink":"http://www.helicunzai.cn/2022/11/22/Java-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%9B%86%E5%90%88%E7%B1%BB/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"http://www.helicunzai.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.helicunzai.cn/tags/Java/"}]},{"title":"Flask:请求与响应","slug":"Flask-请求与响应","date":"2022-11-20T01:39:09.000Z","updated":"2022-11-20T02:49:54.057Z","comments":true,"path":"2022/11/20/Flask-请求与响应/","link":"","permalink":"http://www.helicunzai.cn/2022/11/20/Flask-%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/","excerpt":"","text":"Flask请求 Request请求对象 Request请求对象封装了从客户端发来的请求报文，可以从其中获取请求报文的所有数据。 Request亲请求对象的常用属性方法如下 属性或方法 说明 forms 一个字典，储存请求所提交的表单字段 args 一个字典，储存通过URL查询字符串传递的所有参数 values 一个字典，form和args的合集 cookies 一个字典，存储请求的所有cookie headers 一个字典，存储所有请求的HTTP首部 files 一个字典，存储请求的上传的所有文件 get_data() 返回请求主体的缓冲的数据 get_json 返回一个Python字典，包含解析请求主体后得到的JSON blueprint 返回请求的Flak蓝本的名称 endpoint 处理请求的Flask端点的名称 method HTTP请求方法，可以是GET或POST scheme URL方案(http或https) is_secure 通过安全的连接(HTTPS)发送请求是，返回True host 请求定义的主机名，如果客户端定义了端口号，还包括端口号 path URL路径部分 query_string URL的查询字符串部分，返回原始二进制值 full_path URL的路径和查询字符串部分 url 客户端请求的完整URL base_url 同url,但没有查询字符串部分 remote_addr 客户端的IP地址 environ 请求原始WSGI环境字典 获取GET 使用request.args.get()方法获取GET请求参数 1234567891011from flask import *app=Flask(__name__)@app.route(&quot;/&quot;)def index(): name=request.args.get(&#x27;name&#x27;) age=request.args.get(&#x27;age&#x27;) message=f&quot;姓名&#123;name&#125;\\n年龄&#123;age&#125;&quot;.format(name=name, age=age) return messageif __name__ == &#x27;__main__&#x27;: app.run() 获取POST请求参数 1234567891011121314import requestsfrom flask import *app=Flask(__name__)@app.route(&quot;/login&quot;,methods=[&quot;GET&quot;, &quot;POST&quot;])def login(): if request.method==&#x27;POST&#x27;: username=request.form[&#x27;username&#x27;] password=request.form[&#x27;password&#x27;] message=f&quot;用户名是&#123;username&#125;,密码是&#123;password&#125;&quot; return message return render_template(&#x27;login.html&#x27;)if __name__==&#x27;__main__&#x27;: app.run() 1234567891011121314&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt;表单&lt;/center&gt;&lt;hr&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; value=&quot;&quot;&gt;&lt;br&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; value=&quot;&quot;&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 文件上传 123456789101112131415161718192021222324252627282930313233import os.pathimport uuidimport osfrom flask import *def random_file(filename): ext=os.path.splitext(filename)[1] new_filename=uuid.uuid4().hex+ext return new_filenameapp=Flask(__name__)@app.route(&#x27;/upload&#x27;, methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def upload(): if request.method==&#x27;POST&#x27;: avatar = request.files[&#x27;avatar&#x27;] if avatar: filename=random_file(avatar.filename) avatar.save(os.path.join(&quot;upload&quot;, filename)) return redirect(url_for(&#x27;uploaded_file&#x27;,filename=filename)) return render_template(&#x27;\\\\upload.html&#x27;)@app.route(&#x27;/uploads/&lt;filename&gt;&#x27;)def uploaded_file(filename): return send_from_directory(&quot;upload&quot;, filename)@app.route(&quot;/login&quot;,methods=[&quot;GET&quot;, &quot;POST&quot;])def login(): if request.method==&#x27;POST&#x27;: username=request.form[&#x27;username&#x27;] password=request.form[&#x27;password&#x27;] message=f&quot;用户名是&#123;username&#125;,密码是&#123;password&#125;&quot; return message return render_template(&#x27;login.html&#x27;)if __name__==&#x27;__main__&#x27;: app.run() 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; id=&quot;avatar&quot; name=&quot;avatar&quot; value=&quot;&quot;&gt;&lt;br&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"网站开发","slug":"网站开发","permalink":"http://www.helicunzai.cn/categories/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"网站开发","slug":"网站开发","permalink":"http://www.helicunzai.cn/tags/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"},{"name":"Flask","slug":"Flask","permalink":"http://www.helicunzai.cn/tags/Flask/"}]},{"title":"Flask:蓝图","slug":"Flask-蓝图","date":"2022-11-20T01:17:02.000Z","updated":"2022-11-20T01:38:58.709Z","comments":true,"path":"2022/11/20/Flask-蓝图/","link":"","permalink":"http://www.helicunzai.cn/2022/11/20/Flask-%E8%93%9D%E5%9B%BE/","excerpt":"","text":"蓝图是一个储存操作方法的容器，当它注册到一个应用上后，这些操作就可以被调用。蓝图极大简化了大型应用的工作方式，并给Flask拓展提供了在应用上注册操作的核心方法。 创建蓝图 123456from flask import Blueprintadmin=Blueprint(&quot;admin&quot;,__name__)@admin.route(&quot;/&quot;)def index(): return &quot;&lt;h1&gt;admin&lt;/h1&gt;\\n&quot; 123456from flask import Blueprinthome=Blueprint(&quot;home&quot;,__name__)@home.route(&quot;/&quot;)def index(): return &quot;&lt;h1&gt;home&lt;/h 注册蓝图 1234567891011121314```pythonfrom flask import *from app.home import home as home_blueprintfrom app.admin import admin as admin_blueprintapp=Flask(__name__)app.register_blueprint(home_blueprint,url_prefix=&#x27;/home&#x27;)app.register_blueprint(admin_blueprint,url_prefix=&#x27;/admin&#x27;)@app.route(&quot;/&quot;)def index(): return &quot;&lt;h1&gt;index&lt;/h1&gt;&quot;if __name__ == &#x27;__main__&#x27;: app.run()","categories":[{"name":"网站开发","slug":"网站开发","permalink":"http://www.helicunzai.cn/categories/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"网站开发","slug":"网站开发","permalink":"http://www.helicunzai.cn/tags/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"},{"name":"Flask","slug":"Flask","permalink":"http://www.helicunzai.cn/tags/Flask/"}]},{"title":"matplotlib的使用","slug":"matplotlib的使用","date":"2022-11-19T16:29:54.000Z","updated":"2022-11-19T17:09:05.556Z","comments":true,"path":"2022/11/20/matplotlib的使用/","link":"","permalink":"http://www.helicunzai.cn/2022/11/20/matplotlib%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"单一数据的可视化 在图表中绘制数据 1234567import numpy as npimport matplotlib.pyplot as pltx=np.linspace(0,2*np.pi)y=np.sin(x)plt.plot(x,y)plt.show() 设置图表的显示范围 使用matplotlib.pylot绘制图表时，自动设置图表的显示范围 当然有时候可以使用matplotlib.pylot.xlim([])来指定范围 plt.ylim([0,5]) plt.xlim([0,np.pi]) 123456789import numpy as npimport matplotlib.pyplot as pltx=np.linspace(0,2*np.pi)y=np.sin(x)plt.plot(x,y)plt.ylim([0,5])plt.xlim([0,np.pi])plt.show() 设置图表元素的名称 plt.xlabel(“x-axis”) plt.ylabel( 123456789101112import numpy as npimport matplotlib.pyplot as pltx=np.linspace(0,2*np.pi)y=np.sin(x)plt.plot(x,y)plt.title(&quot;sin&quot;)plt.ylim([0,5])plt.xlabel(&quot;x-axis&quot;)plt.ylabel(&quot;y-axis&quot;)plt.xlim([0,np.pi])plt.show() 在图表中显示网格 plt.grid(True) 12345678910111213import numpy as npimport matplotlib.pyplot as pltx=np.linspace(0,2*np.pi)y=np.sin(x)plt.plot(x,y)plt.title(&quot;sin&quot;)plt.ylim([0,5])plt.xlabel(&quot;x-axis&quot;)plt.ylabel(&quot;y-axis&quot;)plt.xlim([0,np.pi])plt.grid(True)plt.show() 在图表轴上设置刻度 123456789101112131415import numpy as npimport matplotlib.pyplot as pltx = np.linspace(0, 2 * np.pi)y = np.sin(x)plt.plot(x, y)plt.title(&quot;sin&quot;)plt.xlabel(&quot;x-axis&quot;)plt.ylabel(&quot;y-axis&quot;)plt.grid(True)positions = [0, np.pi * 0.5, np.pi, np.pi * 1.5, np.pi * 2]labes = [&quot;0&quot;, &quot;90&quot;, &quot;180&quot;, &quot;270&quot;, &quot;360&quot;]plt.xticks(positions, labes)plt.plot(x,y)plt.show() 多个数据的可视化处理 1","categories":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"}]},{"title":"Flask框架基础","slug":"Flask框架基础","date":"2022-11-14T16:19:56.000Z","updated":"2022-11-20T01:18:10.329Z","comments":true,"path":"2022/11/15/Flask框架基础/","link":"","permalink":"http://www.helicunzai.cn/2022/11/15/Flask%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Flask基础 第一个应用 12345678from flask import Flaskapp=Flask(__name__)@app.route(&#x27;/&#x27;)def index(): return &quot;hello world&quot;if __name__ == &#x27;__main__&#x27;: app.run() 调试 12345678from flask import Flaskapp=Flask(__name__)@app.route(&#x27;/&#x27;)def index(): return &quot;hello world&quot;if __name__ == &#x27;__main__&#x27;: app.run 路由 程序需要每个URL运行哪些代码，所以保存一个URL到Python函数的映射关系。处理URL和函数之间关系的程序称为路由。 12345678910from flask import Flaskapp=Flask(__name__)@app.route(&#x27;/404&#x27;)def index(): return &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot;if __name__ == &#x27;__main__&#x27;: app.run(debug=True,port=8088) 变量规则 在@app.route()函数中添加URL时，该URL有时候是变化的，所以针对这种情况，可以构造有动态部分的URL，也可以在一个函数上添加多个规则。 在给URL添加变量部分时，可以把这些特殊的字段标记为&lt;变量名&gt;的形式，它将作为命名参数传递给函数。要给变量名的类型进行限制，可以用&lt;变量类型:变量名&gt;指定一个可选的类型转换器 1234567891011121314from flask import Flaskapp=Flask(__name__)@app.route(&#x27;/&#x27;)def index(): return &#x27;hello world&#x27;@app.route(&#x27;/user/&lt;username&gt;&#x27;)def show_user_profile(username): return f&#x27;用户名是：&#123;username&#125;&#x27;@app.route(&#x27;/post/&lt;int:post_id&gt;&#x27;)def show_post(post_id): return f&#x27;ID是&#123;post_id&#125;&#x27;if __name__ == &#x27;__main__&#x27;: app.run(debug= True) 构造URL 使用url_for()函数来给指定的函数构造URL。其第一个参数是函数名，其余参数会添加到URL末尾作为查询参数 1234567891011121314from flask import *app=Flask(__name__)@app.route(&#x27;/&#x27;)def index(): return redirect(url_for(&#x27;show_user_profile&#x27;,username=&#x27;bill&#x27;))@app.route(&#x27;/user/&lt;username&gt;&#x27;)def show_user_profile(username): return f&#x27;用户名是：&#123;username&#125;&#x27;@app.route(&#x27;/post/&lt;int:post_id&gt;&#x27;)def show_post(post_id): return f&#x27;ID是&#123;post_id&#125;&#x27;if __name__ == &#x27;__main__&#x27;: app.run(debug= True) HTTP方法 1234567891011121314151617from flask import *app=Flask(__name__)@app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def index(): if request.method==&#x27;POST&#x27;: return redirect(url_for(&#x27;show_user_profile&#x27;,username=&#x27;bill&#x27;)) else: return &quot;Hello&quot;@app.route(&#x27;/user/&lt;username&gt;&#x27;)def show_user_profile(username): return f&#x27;用户名是：&#123;username&#125;&#x27;@app.route(&#x27;/post/&lt;int:post_id&gt;&#x27;)def show_post(post_id): return f&#x27;ID是&#123;post_id&#125;&#x27;if __name__ == &#x27;__main__&#x27;: app.run(debug= True) 模板 模板是一个包含响应文本的文件，其中包含占位变量的动态部分，其具体值只在请求的上下文才知道。 渲染模板 语法格式 1render_template(&#x27;temprender.html&#x27;,username=name) Flask程序默认在templates子文件中找模板 12345678910from flask import Flask,url_for,render_templateapp=Flask(__name__)@app.route(&#x27;/&#x27;)def index(): title=&quot;Flask&quot; msg=&quot;你好&quot; return render_template(&#x27;index.html&#x27;,title=title,msg=msg)if __name__ == &#x27;__main__&#x27;: app.run() 模板变量 &#123;&#123;name&#125;&#125;表示一个变量，是一种特殊的占位符。也可以是列表、字典和对象 还有常用过滤器 123456&lt;!doctype HTML&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;h1&gt;&lt;center&gt;&#123;&#123;msg|upper&#125;&#125;&lt;/center&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 名称 说明 safe 渲染时不转义 capitalize 把值得首字母转为大写，其它字母转为小写 lower 把值转为小写 upper 把值转换为大写形式 title 把值中每个单词的首单词都转换为大写 trim 把值的首尾空格去掉 striptages 渲染之前把值中所有的HTML标签都删掉 控制结构 1234567891011121314from flask import Flask, url_for, render_templateapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index(): title = &quot;Flask&quot; user=&quot;&quot; return render_template(&#x27;index.html&#x27;, title=title,user=user)if __name__ == &#x27;__main__&#x27;: app.run() 123456&lt;!doctype HTML&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;h1&gt;&#123;% if user %&#125;&#123;&#123;user&#125;&#125;&#123;% else %&#125;no user&#123;% endif %&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; Web表单 1pip install flask-wtf 表单类 使用Flask-WTF时候，每个Web表单都继承自Form的类表示 例如 1234567from flask_wtf import FlaskFormfrom wtforms import *from wtforms.validators import DataRequiredclass NameForm(FlaskForm):\\ name=StringField(&#x27;请输入姓名&#x27;,validators=DataRequired()) passwd=PasswordField(&#x27;请输入密码&#x27;,validators=DataRequired()) sumbmit=SubmitField(&quot;提交&quot;) 当然WTForms支持其它HTML标准字段 字段类型 说明 StringField 文本字段 TextAreaField 多行文本字段 PasswordFiled 密码文本字段 HiddenField 隐藏文本字段 DateField 文本字段，值为datetime.date格式 DateTimeField 文本字段，值为datetime.datetime格式 IntegerField 文本字段，值为整数 DecimalField 文本字段，值为decimal.Decimal格式 FloatField 文本字段，值为浮点数 BooleanField 复选框，值为True或False RadioField 一组单选按钮 SelectFiled 下拉列表 SelectMultipleField 下拉列表，可选择多个值 FileField 文件上传字段 SubmitFiled 表单提交按钮 FormFiled 把表单作为字段嵌入另一个表单内 FieldList 一组指定类型的字段 WTForms内置的验证函数 字段类型 说明 Email 验证电子邮箱地址 EqualTo 比较两个字段的值，常用于比较输入两次密码进行确认的情况 IPAdress 验证IPv4地址 Length 验证输入字符串的长度 NumberRange 验证输入的值的在数字范围内 Optional 无输入值时跳过其他验证函数 Required 确保字段中有数据 Regexp 使用正则表达式验证输入值 URL 验证URL AnyOf 确保输入值在可选列表中 把表单渲染成HTML models.py 1234567891011from flask_wtf import FlaskFormfrom wtforms import *from wtforms.validators import DataRequired, Lengthclass LoginForm(FlaskForm): name = StringField(label=&#x27;用户名&#x27;, validators=[DataRequired(&quot;用户名不能为空&quot;), Length(max=10, min=3, message=&quot;用户名要大于3且小于10&quot;)]) password = PasswordField(label=&#x27;密码&#x27;, validators=[DataRequired(&quot;密码不能为空&quot;), Length(max=15, min=6, message=&quot;密码长度大于6且小于15&quot;)]) submit = SubmitField(label=&quot;提交&quot;) main.py 12345678910111213141516171819202122232425from flask import *from models import LoginFormapp = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] =&quot;HELLO&quot;@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def login(): form = LoginForm() if form.validate_on_submit(): username = form.name.data password = form.password.data if username == &quot;bill&quot; and password ==&quot;myfile12&quot;: return redirect(url_for(&#x27;index&#x27;)) return render_template(&quot;login.html&quot;,form=form)@app.route(&#x27;/&#x27;)def index(): return render_template(&quot;index.html&quot;, title=&quot;首页&quot;, user=&quot;用户&quot;)if __name__ == &#x27;__main__&#x27;: app.run(debug=True) 1234567891011121314151617181920212223&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt;表单&lt;/center&gt;&lt;hr&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &#123;&#123;form.name.label&#125;&#125; &#123;&#123;form.name()&#125;&#125; &#123;% for err in form.name.errors %&#125; &lt;p style=&quot;color: red&quot;&gt;&#123;&#123;err&#125;&#125;&lt;/p&gt; &#123;% endfor %&#125; &#123;&#123;form.password.label&#125;&#125; &#123;&#123;form.password()&#125;&#125; &#123;% for err in form.password.errors %&#125; &lt;p style=&quot;color: red&quot;&gt;&#123;&#123;err&#125;&#125;&lt;/p&gt; &#123;% endfor %&#125; &#123;&#123;form.csrf_token&#125;&#125; &#123;&#123;form.submit()&#125;&#125; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"网站开发","slug":"网站开发","permalink":"http://www.helicunzai.cn/categories/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"网站开发","slug":"网站开发","permalink":"http://www.helicunzai.cn/tags/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"},{"name":"Flask","slug":"Flask","permalink":"http://www.helicunzai.cn/tags/Flask/"}]},{"title":"Pandas基础","slug":"Pandas基础","date":"2022-11-13T10:18:08.000Z","updated":"2022-11-19T16:29:11.673Z","comments":true,"path":"2022/11/13/Pandas基础/","link":"","permalink":"http://www.helicunzai.cn/2022/11/13/Pandas%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Pandas Pandas 一个强大的分析结构化数据的工具集，基础是Numpy（提供高性能的矩阵运算）。Pandas 可以从各种文件格式比如 CSV、JSON、SQL、Microsoft Excel 导入数据。Pandas 可以对各种数据进行运算操作，比如归并、再成形、选择，还有数据清洗和数据加工特征。Pandas 广泛应用在学术、金融、统计学等各个数据分析领域。 Pandas 的主要数据结构是 Series （一维数据）与 DataFrame（二维数据），这两种数据结构足以处理金融、统计、社会科学、工程等领域里的大多数典型用例。 Series 创建 123import pandas as pdfruits=&#123;&quot;origin&quot;:2,&quot;bannaa&quot;:8&#125;print(pd.Series(fruits)) 12345import pandas as pdindex =[&quot;apple&quot;,&quot;dog&quot;,&quot;cat&quot;,&quot;pig&quot;,&quot;orange&quot;]data =[8,2,1,3,2]series=pd.Series(data,index=index)print(series) 数据的引用 12345import pandas as pdindex =[&quot;apple&quot;,&quot;dog&quot;,&quot;cat&quot;,&quot;pig&quot;,&quot;orange&quot;]data =[8,2,1,3,2]series=pd.Series(data,index=index)print(series[0:2]) 12345import pandas as pdindex =[&quot;apple&quot;,&quot;dog&quot;,&quot;cat&quot;,&quot;pig&quot;,&quot;orange&quot;]data =[8,2,1,3,2]series=pd.Series(data,index=index)print(series[[&quot;dog&quot;,&quot;pig&quot;]]) 数据与索引的读取 1234567import pandas as pdindex =[&quot;apple&quot;,&quot;dog&quot;,&quot;cat&quot;,&quot;pig&quot;,&quot;orange&quot;]data =[8,2,1,3,2]series=pd.Series(data,index=index)series_values =series.valuesseries_index =series.indexprint(series_values,series_index) 元素的添加 在向Series中添加元素时，要添加的元素必须是Series类型的数据 1234567891011import pandas as pdindex =[&quot;apple&quot;,&quot;dog&quot;,&quot;cat&quot;,&quot;pig&quot;,&quot;orange&quot;]data =[8,2,1,3,2]series=pd.Series(data,index=index)#方式一series=series.append(pd.Series([12],index=[&quot;goose&quot;]))series.append(pd.Series (&#123;&quot;orange&quot;:45&#125;))#方法二grap=pd.Series([1],index=[&quot;grap&quot;])series.append(series)print(series) 元素的删除 通过设置series数据的索引来实现元素的删除 123456import pandas as pdindex =[&quot;apple&quot;,&quot;dog&quot;,&quot;cat&quot;,&quot;pig&quot;,&quot;orange&quot;]data =[8,2,1,3,2]series=pd.Series(data,index=index)series=series.drop(&quot;cat&quot;)print(series) 过滤 123456import pandas as pdindex =[&quot;apple&quot;,&quot;dog&quot;,&quot;cat&quot;,&quot;pig&quot;,&quot;orange&quot;]data =[8,2,1,3,2]series=pd.Series(data,index=index)conditions=[True,False,True,False,False]print(series[conditions]) 12345import pandas as pdindex =[&quot;apple&quot;,&quot;dog&quot;,&quot;cat&quot;,&quot;pig&quot;,&quot;orange&quot;]data =[8,2,1,3,2]series=pd.Series(data,index=index)print(series[series%2==0]) 排序 123456import pandas as pdindex =[&quot;apple&quot;,&quot;dog&quot;,&quot;cat&quot;,&quot;pig&quot;,&quot;orange&quot;]data =[8,2,1,3,2]series=pd.Series(data,index=index)print(series.sort_values())print(series.sort_index()) DataFrame DataFrame就像将多个Series数据捆绑在一起的二维数据结构 创建 123456import pandas as pddata=&#123;&quot;fruits&quot;:[&quot;apple&quot;,&quot;orange&quot;,&quot;banana&quot;,&quot;peach&quot;], &quot;num&quot;:[1,34,23,54], &quot;year&quot;:[2000,2023,2015,2045]&#125;df=pd.DataFrame(data)print(df) 设置索引和列 DateFrame类型的变量df的索引可以通过将长度与其行数相同的的列表代入df.index来实现 df的列可以通过将与其列相同的列代入df.columns中来实现 123456789101112131415import pandas as pdindex=[&quot;apple&quot;,&quot;orange&quot;,&quot;banna&quot;,&quot;strawberry&quot;,&quot;kiwifruit&quot;]data1=[10,5,8,12,3]data2=[30,25,12,10,8]series1=pd.Series(data1,index=index)series2=pd.Series(data2,index=index)df=pd.DataFrame([series1,series2])print(df)df.index=[1,2]print(&quot;&quot;)print(df)print()df.columns=[1,2,3,4,5]print(df) 添加行 添加新的数据到DataFrame中。对DataFrame类型变量df调用df.append(&quot;series类型数据“，ignore_index=True) 添加列 对DateFrame类型调用df[“新列”] 数据的引用","categories":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"}]},{"title":"机器学习:性能评价指标与PR曲线","slug":"机器学习-性能评价指标与PR曲线","date":"2022-11-13T03:45:27.000Z","updated":"2022-11-19T16:03:13.258Z","comments":true,"path":"2022/11/13/机器学习-性能评价指标与PR曲线/","link":"","permalink":"http://www.helicunzai.cn/2022/11/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87%E4%B8%8EPR%E6%9B%B2%E7%BA%BF/","excerpt":"","text":"混淆矩阵 混淆矩阵： 真阳性(TP):预测为阳性，实际为阳 真阴性(TN):预测为阴性，实际为阴 假阳性(FP):预测为阳性，实际为阴 假阴性(FN):预测为阴性，实际为阳 准确率 准确率为是指在所有事件中预测结果与实际情况相符的事件所占比例 F值 机器学习中使用精确率(precision)、召回率(recall)、F值等指标进行性能评估 精确率 预测问阳的数据中，实际为阳的比例 召回率 实际为阳的数据，被预测为阳的比例 F值 F值是由精确率与召回率组合计算的值(调和平均) 编程 12345678910import numpyfrom sklearn.metrics import *y_true=[0,0,0,1,1,1]y_pred=[1,0,0,1,1,1]comfmat=confusion_matrix(y_true,y_pred)print(&quot;混淆矩阵:\\n&quot;,comfmat)print(&quot;精确率:&quot;,precision_score(y_true,y_pred))print(&quot;召回率:&quot;,recall_score(y_true,y_pred))print(&quot;F1:&quot;,f1_score(y_true,y_pred)) PR曲线 召回率与精确率的关系: 召回率与精准率成反比例 纵轴为精确率,横轴为召回率 基于PR曲线的模型评估 由于精确率与召回率成反比例，一个升高则另一个降低 不过存在精确率与召回率相同的点，该点被称为平衡点(Break Even Point,BEP)","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.helicunzai.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.helicunzai.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"人工智能","slug":"人工智能","permalink":"http://www.helicunzai.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"PyMysql:对数据库服务器的操作","slug":"PyMysql-对数据库服务器的操作","date":"2022-11-11T23:54:26.000Z","updated":"2022-11-12T01:19:49.822Z","comments":true,"path":"2022/11/12/PyMysql-对数据库服务器的操作/","link":"","permalink":"http://www.helicunzai.cn/2022/11/12/PyMysql-%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"安装PyMySql 1pip install pymysql 连接对象 获取连接对象 123456789import pymysqltry: connection=pymysql.connect(host=&#x27;112.245.212.109&#x27;,port=3306,user=&#x27;db1&#x27;,password=&#x27;yyds&#x27;,db=&#x27;db1 &#x27;,charset=&#x27;utf8&#x27;) print(connection)except Exception as e: print(e) 连接对象的常用方法 方法 说明 cursor() 获取游标对象，操作数据库 commit() 提交事物 rollback() 回滚事物 close() 关闭数据库连接 游标对象 获取游标对象 1cursor=connection.cursor() 游标对象的常用方法 方法 说明 execute() 执行数据库操作 executemany() 用于批量操作 fetchone() 获取查询结果集中的下一条记录 fetchmany() 获取指定数量的记录 fetchall() 获取结构集合所有记录 close() 关闭当前游标 操作 123456789101112import pymysqltry: connection=pymysql.connect(host=&#x27;116.205.228.29&#x27;,port=3306,user=&#x27;db1&#x27;,password=&#x27;TCy3KWW4T5k5W8eG&#x27;,db=&#x27;db1&#x27;,charset=&#x27;utf8&#x27;) print(connection)except Exception as e: print(e)cursor=connection.cursor()cursor.execute(&quot;SELECT * FROM student;&quot;)data=cursor.fetchall()for i in data: print(&quot;学号&quot;+i[0].strip()+&quot;; 姓名:&quot;+i[1].strip()+&quot;;&quot;)","categories":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"数据库","slug":"数据库","permalink":"http://www.helicunzai.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Python:网络编程基础","slug":"Python-网络编程基础","date":"2022-11-10T02:56:43.000Z","updated":"2022-11-11T16:03:29.396Z","comments":true,"path":"2022/11/10/Python-网络编程基础/","link":"","permalink":"http://www.helicunzai.cn/2022/11/10/Python-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Socket 为了让两个程序进行网络通信，二者均需要使用socket套接字。套接字用来描述IP地址和端口，是一个通信链的句柄。 在Python中使用socket模块的socket模块，语法格式 1s=socket.socket(AddressFamily,Type) 该函数带有两个参数 Address Family:可以选择AF_INET(用于Internet进程间通信)或者AF_UNIX(用于同一台机器进程间通信) Type:套接字协议，可以是SOCK_STREAM(流式套接字，主要用于TCP协议)或者SOCK_DGRAM(数据报套接字，主要用于UDP协议) 如创建TCP/IP套接字 1tcpsocket=socket.socket(socket.AF_INET,socket.SOCK_STREAM) 创建UDP/IP套接字 1udpSock=socket.socket(socket.AF_INET, socket.SOCK_DGRAM) socket对象内置方法 方法 描述 s.bind() 绑定地址(hos,port)到套接字,在AF_INET下元组(host,port)的形式表示地址 s.listen() 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。最少为一 s.accept() 被动接收TCP客户端连接，(阻塞式)等待连接的到来 s.connect() 主动初始化TCP服务连接，一般address的格式为元组(hostname,port),如果连接出错，返回socket.error错误 s.recv() 接收TCP数据，以字符串形式返回。bufsize指定要接收的最大数据量；flag提供有关消息的其它信息，通常可以忽略。 s.send() 发送TCP数据，将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数量。成功返回None,失败抛出异常 s.sendall() 完整发送TCP数据，将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数量。成功返回None,失败抛出异常 s.recvfrom() 接收UDP数据，返回值为(data,address)元组，其中data是包含接收数据的字符串，address是发送数据的套接字地址 s.sendto() 发送UDP数据，与recv类似，address形式为(ipaddr,port)的元组，指定远程地址。返回值为发送的字节数 s.close() 关闭套接字 TCP编程 创建TCP服务 12345678910111213141516import socket # 导入 socket 模块s=socket.socket()host = &#x27;0.0.0.0&#x27; # 获取本地主机名port = 34222 # 设置端口s.bind((host, port))s.listen(2)print(&quot;waiting for connection&quot;)while True: con,addr=s.accept() data=con.recv(1024) str1=str(data.decode()) print(data.decode()) str1=&quot;你发送了:&quot;+str1+&quot;\\n&quot; con.sendall(str1.encode()) con.close()print(&quot;endall&quot;) 创建TCP客户端 12345678910import sockets = socket.socket()host = &#x27;175.178.38.129&#x27;port = 34222s.connect((host, port))send_data =input(&quot;输入：&quot;)s.send(send_data.encode())recvDATA=s.recv(1024).decode()print(recvDATA)s.close() UDP编程 UDP服务器 12345678import sockets=socket.socket(socket.AF_INET, socket.SOCK_DGRAM)s.bind((&#x27;127.0.0.1&#x27;,8888))data,addr=s.recv(1024)print(&quot;data: &quot;,data)str=input(&quot;input:&quot;)s.sendall(str,addr)s.close() UDP客户端 123456import sockets=socket.socket(socket.AF_INET, socket.SOCK_DGRAM)data=input(&quot;input:&quot;)s.sendall(data.encode(),(&#x27;127.0.0.1&#x27;,8888))print(s.recv(1024).decode())s.close()","categories":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"网络编程","slug":"网络编程","permalink":"http://www.helicunzai.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]},{"title":"K-means聚类算法筛实现鸢尾花聚类","slug":"K-means聚类算法筛实现鸢尾花聚类","date":"2022-11-04T15:23:09.000Z","updated":"2022-11-05T07:49:31.002Z","comments":true,"path":"2022/11/04/K-means聚类算法筛实现鸢尾花聚类/","link":"","permalink":"http://www.helicunzai.cn/2022/11/04/K-means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E7%AD%9B%E5%AE%9E%E7%8E%B0%E9%B8%A2%E5%B0%BE%E8%8A%B1%E8%81%9A%E7%B1%BB/","excerpt":"","text":"K-means聚类算法筛实现鸢尾花聚类:对于给定的样本集，按照样本之间的距离大小，将样本集划分为K个簇，让簇内的点尽量紧密的连在一起，而让簇间的距离尽量的。聚类属于无监督算法，不必专门切分训练集与测试集 导入包 1234import matplotlib.pyplot as pltimport numpy as npfrom sklearn.cluster import KMeans from sklearn import datasets sklearn.datasets中加载数据集 1234# 直接从sklearn中获取数据集iris = datasets.load_iris()X = iris.data[:, :4] # 表示我们取特征空间中的4个维度print(X.shape) 绘制二维数据分布图 1234567# 取前两个维度（萼片长度、萼片宽度），绘制数据分布图plt.scatter(X[:, 0], X[:, 1], c=&quot;red&quot;, marker=&#x27;o&#x27;, label=&#x27;see&#x27;)plt.xlabel(&#x27;sepal length&#x27;)plt.ylabel(&#x27;sepal width&#x27;)plt.legend(loc=2)plt.show() 实例化K-means类，并且定义训练函数 123456def Model(n_clusters): estimator = KMeans(n_clusters=n_clusters)# 构造聚类器 return estimatordef train(estimator): estimator.fit(X) # 聚类 训练 123# 初始化实例，并开启训练拟合estimator=Model(3) train(estimator) 可视化展示 123456789101112label_pred = estimator.labels_ # 获取聚类标签# 绘制k-means结果x0 = X[label_pred == 0]x1 = X[label_pred == 1]x2 = X[label_pred == 2]plt.scatter(x0[:, 0], x0[:, 1], c=&quot;red&quot;, marker=&#x27;o&#x27;, label=&#x27;label0&#x27;)plt.scatter(x1[:, 0], x1[:, 1], c=&quot;green&quot;, marker=&#x27;*&#x27;, label=&#x27;label1&#x27;)plt.scatter(x2[:, 0], x2[:, 1], c=&quot;blue&quot;, marker=&#x27;+&#x27;, label=&#x27;label2&#x27;)plt.xlabel(&#x27;sepal length&#x27;)plt.ylabel(&#x27;sepal width&#x27;)plt.legend(loc=2)plt.show()","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.helicunzai.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.helicunzai.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"人工智能","slug":"人工智能","permalink":"http://www.helicunzai.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"SVM(支持向量机)——鸢尾花分类","slug":"SVM鸢尾花分类","date":"2022-11-02T03:43:03.000Z","updated":"2022-11-04T15:28:51.779Z","comments":true,"path":"2022/11/02/SVM鸢尾花分类/","link":"","permalink":"http://www.helicunzai.cn/2022/11/02/SVM%E9%B8%A2%E5%B0%BE%E8%8A%B1%E5%88%86%E7%B1%BB/","excerpt":"","text":"scikit-learn sklearn (scikitlearn.com.cn) scikit-learn 是基于 Python 语言的机器学习工具 加载相关包 数据下载 123456import numpy as npfrom matplotlib import colorsfrom sklearn import svm from sklearn import model_selectionimport matplotlib.pyplot as pltimport matplotlib as mpl 加载数据、切分数据集 12345678910111213def iris_type(s): it = &#123;b&#x27;Iris-setosa&#x27;:0, b&#x27;Iris-versicolor&#x27;:1,b&#x27;Iris-virginica&#x27;:2&#125; return it[s]#数据准备data = np.loadtxt(&#x27;iris.data&#x27;, # 数据文件路径i dtype=float, # 数据类型 delimiter=&#x27;,&#x27;, # 数据分割符 converters=&#123;4:iris_type&#125;) # 将第五列使用函数iris_type进行转换# 数据分割x, y = np.split(data, (4, ), axis=1) # 数据分组 第五列开始往后为y 代表纵向分割按列分割x = x[:, :2]x_train, x_test, y_train, y_test=model_selection.train_test_split(x, y, random_state=1, test_size=0.2 大概鸢尾花的数据如上图，我们要做的就是分类 在超平面上将不同品种数据分割开 SVM分类器的构建 1234567def classifier(): clf = svm.SVC(C=0.8, # 误差项惩罚系数 kernel=&#x27;linear&#x27;, # 线性核 高斯核 rbf decision_function_shape=&#x27;ovr&#x27;) # 决策函数 return clfdef train(clf, x_train, y_train): clf.fit(x_train, y_train.ravel()) # 训练集特征向量和 训练集目标值 C为误差项惩罚系：其越大要求拟合越高，相应泛化能力减弱 kernel有线性核,高斯核 ,rbf核 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#加载相关包import numpy as npfrom matplotlib import colorsfrom sklearn import svmfrom sklearn import model_selectionimport matplotlib.pyplot as pltimport matplotlib as mpldef iris_type(s): it = &#123;b&#x27;Iris-setosa&#x27;:0, b&#x27;Iris-versicolor&#x27;:1,b&#x27;Iris-virginica&#x27;:2&#125; return it[s]data = np.loadtxt(&#x27;iris.data&#x27;, dtype=float, # 数据类型 delimiter=&#x27;,&#x27;, # 数据分割符 converters=&#123;4:iris_type&#125;) # 将第五列使用函数iris_type进行转换x,y=np.split(data,(4,),axis=1)#将第5列设为yx=x[:,:2]x_train, x_test, y_train, y_test=model_selection.train_test_split(x, y, random_state=1, test_size=0.2)# SVM分类器构建def classifier(): clf = svm.SVC(C=0.81, # 误差项惩罚系数 kernel=&#x27;linear&#x27;, # 线性核 高斯核 rbf decision_function_shape=&#x27;ovr&#x27;) # 决策函数 return clfdef train(clf, x_train, y_train): clf.fit(x_train, y_train.ravel()) # 训练集特征向量和 训练集目标值# 2 定义模型 SVM模型定义clf = classifier()train(clf, x_train, y_train)def show_accuracy(a, b, tip): acc = a.ravel() == b.ravel() print(&#x27;%s Accuracy:%.3f&#x27; % (tip, np.mean(acc)))# 分别打印训练集和测试集的准确率 score(x_train, y_train)表示输出 x_train,y_train在模型上的准确率def print_accuracy(clf, x_train, y_train, x_test, y_test): print(&#x27;training prediction:%.3f&#x27; % (clf.score(x_train, y_train))) print(&#x27;test data prediction:%.3f&#x27; % (clf.score(x_test, y_test))) # 原始结果和预测结果进行对比 predict() 表示对x_train样本进行预测,返回样本类别 show_accuracy(clf.predict(x_train), y_train, &#x27;traing data&#x27;) show_accuracy(clf.predict(x_test), y_test, &#x27;testing data&#x27;) # 计算决策函数的值 表示x到各个分割平面的距离 print(&#x27;decision_function:\\n&#x27;, clf.decision_function(x_train))def draw(clf, x): iris_feature = &#x27;sepal length&#x27;, &#x27;sepal width&#x27;, &#x27;petal length&#x27;, &#x27;petal width&#x27; # 开始画图 x1_min, x1_max = x[:, 0].min(), x[:, 0].max() x2_min, x2_max = x[:, 1].min(), x[:, 1].max() # 生成网格采样点 x1, x2 = np.mgrid[x1_min:x1_max:200j, x2_min:x2_max:200j] # 测试点 grid_test = np.stack((x1.flat, x2.flat), axis=1) print(&#x27;grid_test:\\n&#x27;, grid_test) # 输出样本到决策面的距离 z = clf.decision_function(grid_test) print(&#x27;the distance to decision plane:\\n&#x27;, z) grid_hat = clf.predict(grid_test) # 预测分类值 得到[0, 0, ..., 2, 2] print(&#x27;grid_hat:\\n&#x27;, grid_hat) # 使得grid_hat 和 x1 形状一致 grid_hat = grid_hat.reshape(x1.shape) cm_light = mpl.colors.ListedColormap([&#x27;#A0FFA0&#x27;, &#x27;#FFA0A0&#x27;, &#x27;#A0A0FF&#x27;]) cm_dark = mpl.colors.ListedColormap([&#x27;g&#x27;, &#x27;b&#x27;, &#x27;r&#x27;]) plt.pcolormesh(x1, x2, grid_hat, cmap=cm_light) plt.scatter(x[:, 0], x[:, 1], c=np.squeeze(y), edgecolor=&#x27;k&#x27;, s=50, cmap=cm_dark) plt.scatter(x_test[:, 0], x_test[:, 1], s=120, facecolor=&#x27;none&#x27;, zorder=10) plt.xlabel(iris_feature[0], fontsize=20) plt.ylabel(iris_feature[1], fontsize=20) plt.xlim(x1_min, x1_max) plt.ylim(x2_min, x2_max) plt.title(&#x27;Iris data classification via SVM&#x27;, fontsize=30) plt.grid() plt.show()print(&#x27;-------- eval ----------&#x27;)print_accuracy(clf, x_train, y_train, x_test, y_test)# 5 模型使用print(&#x27;-------- show ----------&#x27;)draw(clf, x)","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.helicunzai.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://www.helicunzai.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"人工智能","slug":"人工智能","permalink":"http://www.helicunzai.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"JSP:隐式对象","slug":"JSP-隐式对象","date":"2022-11-01T09:33:34.000Z","updated":"2022-11-05T14:14:25.978Z","comments":true,"path":"2022/11/01/JSP-隐式对象/","link":"","permalink":"http://www.helicunzai.cn/2022/11/01/JSP-%E9%9A%90%E5%BC%8F%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"JSP隐式对象是JSP容器为每个页面提供的Java对象，开发者可以直接使用它们而不用显式声明。JSP隐式对象也被称为预定义变量。 对象 描述 request HttpServletRequest 接口的实例 response HttpServletResponse 接口的实例 out JspWriter类的实例，用于把结果输出至网页上 session HttpSession类的实例 application ServletContext类的实例，与应用上下文有关 config ServletConfig类的实例 pageContext PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问 page 类似于Java类中的this关键字 Exception Exception类的对象，代表发生错误的JSP页面中对应的异常对象 request 对象 常用方法 方法 说明 Object getAttribute(String name) 返回指定属性的属性值 Enumeration getAttributeNames 返回所有可用属性名的枚举 String getCharaterEncoding 返回字符编码方式 int getContentLength() 返回请求体的字节数 String getContentType() 返回请求体的MIME类型 ServletInputStream getInputStream() 返回请求体的一行二进制流 String getParameter(String name) 返回name指定参数的参数值 Enumeration getParameterNames() 返回可用参数名的枚举 String[] getParameterValues(String name) 返回包含参数name的所有值的数组 String getProtocol() 返回请求用的协议类型及版本号 String getServerName() 返回接收请求的服务器主机名 int getServerPort() 返回服务器接收此请求的端口号 String getRemoteAddr() 返回发送此请求的客户端IP地址 String getRemoteHost() 返回发送此请求的客户端主机名 void setAttribute(String key,Obeject obj) 设置属性的属性值 String geRealPath(String path) 返回一虚拟路径的真实路径","categories":[{"name":"Java","slug":"Java","permalink":"http://www.helicunzai.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.helicunzai.cn/tags/Java/"},{"name":"网站","slug":"网站","permalink":"http://www.helicunzai.cn/tags/%E7%BD%91%E7%AB%99/"}]},{"title":"JSP语法","slug":"JSP语法","date":"2022-10-29T14:40:21.000Z","updated":"2022-11-01T09:20:52.218Z","comments":true,"path":"2022/10/29/JSP语法/","link":"","permalink":"http://www.helicunzai.cn/2022/10/29/JSP%E8%AF%AD%E6%B3%95/","excerpt":"","text":"JSP脚本元素 Java程序片 在标记符&lt;%和 %&gt;之间插入的Java代码被称为JSP页面的Java程序片。 一个JSP页面可以有任意段Java程序片段，这些片段将被JSP引擎(如Tomcat)按顺序执行。在 一个程序片中声明的变量被为JSP页面的局部变量，他们在JSP后记所有的程序片以及表达式内都有效。 当多个客户请求一个JSP页面时,JSP引擎为每个客户启动一个线程，不同线程分别执行该JSP中程序片，程序片中的局部变量会在不同的线程被分配不同的内存空间，因此一个客户对JSP页面局部变量操作的结果不会影响到其它客户 123456789101112131415&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% int i=0; for(i=0;i&lt;10;i++) &#123; out.print(&quot;&lt;h2&gt;&quot;+i+&quot;&lt;/h2&gt;&quot;); &#125;%&gt;&lt;/body&gt;&lt;/html&gt; 成员变量与方法的声明 在标识符 &lt;%!和 %&gt;之间声明的变量被称为JSP页面的成员变量。 123&lt;%! int n=0;%&gt; 在标识符 &lt;%!和 %&gt;之间声明的方法被称为JSP页面的成员方法。 123456789101112131415161718192021&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%! int n=0; int add(int x,int y) &#123; return x+y; &#125;%&gt;&lt;% out.print(&quot;&lt;h1&gt;被请求&quot;+(n++)+&quot;次&lt;/h1&gt;&quot;); out.print(&quot;&lt;p&gt;1+2=&quot;+add(1,2)+&quot;&lt;/p&gt;&quot;);%&gt;&lt;/body&gt;&lt;/html&gt; JAVA表达式 在标识符&lt;%=和%&gt;之间插入一个表达式，可以有算术表达式、逻辑表达式和条件表达式。 1234567891011121314151617181920&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% out.print(&quot;&lt;p&gt;2+2=&quot;);%&gt;&lt;%=2+2%&gt;&lt;% out.print(&quot;&lt;/p&gt;&lt;p&gt;2==2:&quot;);%&gt;&lt;%=2==2%&gt;&lt;% out.print(&quot;&lt;/p&gt;&quot;);%&gt;&lt;/body&gt;&lt;/html&gt; JSP指令标记 page 指令 page指令用来定义整个JSP页面的一些属性和属性值。 page指令格式: &lt;% @ page 属性=“值1” %&gt; contentType import language pageEncoding include 指令 include指令标记就是将jsp文件、或其它文件静态嵌入当前jsp文件 语法格式 &lt;%include file=&quot;url&quot;%&gt; JSP动作标记 include 动作标记 动作标记include就是让JSP文件动态嵌入当前JSP文件 1&lt;jsp:include page=&quot;url&quot;/&gt; 或者 123&lt;jsp:include page=&quot;url&quot;&gt;子标签&lt;jsp:include/&gt; 以下是include动作相关的属性列表。 属性 描述 page 包含在页面中的相对URL地址。 flush 布尔属性，定义在包含资源前是否刷新缓存区。 forward 动作标签 jsp:forward动作把请求转到另外的页面。jsp:forward标记只有一个属性page。语法格式如下所示： &lt;jsp:forward page=&quot;相对 URL 地址&quot; /&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.helicunzai.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.helicunzai.cn/tags/Java/"},{"name":"网站","slug":"网站","permalink":"http://www.helicunzai.cn/tags/%E7%BD%91%E7%AB%99/"}]},{"title":"机器学习概念","slug":"机器学习概念","date":"2022-10-27T04:28:37.000Z","updated":"2022-10-29T03:37:31.073Z","comments":true,"path":"2022/10/27/机器学习概念/","link":"","permalink":"http://www.helicunzai.cn/2022/10/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E5%BF%B5/","excerpt":"","text":"机器学习概念 所谓“机器学习”就是通过对数据进行反复得学习，来找出其中的规律和模式。 机器学习（Machine Learning）是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科 。专门研究计算机怎样模拟或实现人类的学习行为，以获取新知识或技能，重新组织已有的知识结构使之不断改善自身的性能。 各类机器学习算法 监督学习 监督学习（supervised learning）：从给定的有标注的训练数据集中学习出一个函数(模型参数)，当新的数据到来时可以根据这个函数预测结果。 常见任务包括分类与回归 分类问题：对数据所属类别进行预测 回归问题：连续变化的数值进行预测 无监督学习 无监督学习（unsupervised learning）：没有标注的训练数据集，需要根据样本间的统计规律对样本集进行分析，常见任务如聚类等 半监督学习 半监督学习(Semi-supervised learning)结合（少量的）标注训练数据和(大量的）未标注数据来进行数据的分类学习。 一般情况下，我们需要在某些假设的基础上来建立未标记数据和目标之间的联系。目前，在半监督学习中有两个常用的基本假设（两种假设都是基于“相似的样本拥有相似的输出”）： 聚类假设 是指相同聚类中的数据有较大的可能有相同的标记（假设数据存在簇结构，同一个簇的样本属于同一个类别）。根据该假设，决策边界就应该尽量通过数据较为稀疏的地方，从而避免把稠密的聚类中的数据点分到决策边界两侧。如 TSVM算法 流形假设 （将高纬数据嵌入到低维流形中，当两个样例处于低维流行中的一个小局部领域内时，它们具有 相似的类标签），是指处于一个很小的局部领域内的数据具有相似的性质，其标记也应该相似（这一假设反映了决策函数的局部平滑性。）。 因此，流形假设可看做聚类假设的推广，但流形假设对输出值没有限制，因此比聚类假设的适用范围更广，可用于更多类型的学习任务。 和聚类假设的主要不同是，聚类假设主要关注的是整体特性，流形假设主要考虑的是模型的局部特性。 强化学习 强化学习（Reinforcement Learning）：外部环境对输出只给出评价信息而非正确答案，学习机通过强化受奖励的动作来改善自身的性能。 机器学习解决的问题 分类问题 回归问题 聚类问题 其它问题 分类问题 分类问题是监督学习的一个核心问题，它从数据中学习一个分类决策函数或分类模型(分类器(classifier))，对新的输入进行输出预测，输出变量取有限个离散值。 决策树 决策树 树状结构 非叶节点：对应一个特征属性，每个分支代表这个特征属性在某个值域上的输出 叶节点：对应一个类别 决策过程 根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，直到到达叶子节点，将叶子节点存放的类别作为决策结果 构建决策树 特征选择：选取对训练数据具有分类能力的特征 决策树生成：在决策树各个点上按照一定方法选择特征，递归构建决策树 决策树剪枝：在已生成的树上减掉一些子树或者叶节点，从而简化分类树模型 选择分类特征 ID3算法 C4.5算法 CART算法 剪枝 在生成树的过程中，如果没有剪枝（pruning）操作，就生成一个对训练集完全拟合的决策树，但这是对测试集非常不友好的，泛化能力较差. 预剪枝 思想：通过提前停止树的构建而对树剪枝，一旦停止，节点就是叶子，该叶子表示的类为子集中样本数量的类 预剪枝方法： 预定义树高度：当决策树达到该高度时就停止生长 达到阈值：节点实例个数、系统性能增益等 理想的决策树有三种： （1）叶子节点数最少（横向决策次数少） （2）叶子节点深度最小（纵向决策次数少） （3）叶子节点数最少且叶子节点深度最小 后剪枝方法： 首先构造完整的决策树 然后对那些置信度不够的结点子树用叶子结点来代替，该叶子的类标号用该结点子树中最频繁的类标记。 简单、合理（预剪枝方法中精确地估计何时停止树增长很困难） SVM优点支持向量机 支持向量机（Support Vector Machine ） 有监督学习方法，它尝试寻找一个最优决策边界，使距离两个类别最近的样本最远 优点 相对于其他分类算法不需要过多样本，并且由于SVM引入了核函数，所以SVM可以处理高维样本 结构风险最小，这种风险是指分类器对问题真实模型的逼近与问题真实解之间的累积误差 非线性，是指SVM擅长应付样本数据线性不可分的情况，主要通过松弛变量（也叫惩罚变量）和核函数技术来实现，这一部分也正是SVM的精髓所在 集成学习 集成学习通过将多个弱分类器集成在一起，使它们共同完成学习任务，构建一个强分类器。潜在哲学思想是“三个臭皮匠赛过诸葛亮” 回归问题 回归分析用于预测输入变量（自变量）和输出变量（因变量）之间的关系，特别是当输入变 量的值发生变化时，输出变量值随之发生变化 线性回归算法 线性回归算法假设特征和结果满足线性关系，意味着可以将输入项分别乘以一些常量，再 将结果加起来得到输出 聚类问题 聚类问题是无监督学习的问题，算法的思想就是“物以类聚，人以群分”，聚类算法感知样本 间的相似度，进行类别归纳，对新的输入进行输出预测，输出变量取有限个离散值 K-Means K-means（又称k-均值或k-平均）聚类算法。算法思想就是首先随机确定k个中心点作为聚类中心，然后把每个数据点分配给最邻近的中心点，分配完成后形成k个聚类，计算各个聚类的平均中心点，将其作为该聚类新的类中心点，然后重复迭代上述步骤直到分配过程不再产生变化。 机器学习一般过程 [ ] 数据收集 [ ] 数据清洗(清除重复或缺失的数据，以提高数据的精度) [ ] 运用机器学习算法对数据进行学习 [ ] 使用测试数据对性能进行评测 [ ] 部署模型","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.helicunzai.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://www.helicunzai.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"人工智能","slug":"人工智能","permalink":"http://www.helicunzai.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"Django:快速入门介绍","slug":"Django-快速入门介绍","date":"2022-10-17T07:11:17.000Z","updated":"2022-10-17T08:03:33.340Z","comments":true,"path":"2022/10/17/Django-快速入门介绍/","link":"","permalink":"http://www.helicunzai.cn/2022/10/17/Django-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"创建项目 在Pycharm专业版这可以直接创建Django项目 也可以在创建空项目,在终端中输入 1django-admin startproject quickstart 我们就可以发现目录生成一下文件结构 quickstart/ manage.py quickstart/ _init_.py settings.py urls.py wsgi.py 说明： 外层quickstart只是名字，可以替换 manage.py是一个命令行程序，允许用户以各种方式与此项目进行交互 quickstart/init.py为空文件，告诉python其为一个包 quickstart/settings.py为项目配置文件 quickstart/urls.py是项目URL声明 quickstart/wsgi.py是使用WSGI部署服务的入口 创建应用 我们在终端输入以下命令创建应用 1django-admin startapp myapp 我们就可以发现目录生成一下文件结构 myapp/ _init_.py admin.py migrations.py _init_.py tests.py models.py views.py 说明： admin.py用于定制应用的管理页面 migrations.py文件夹用于模型出现修改时对应数据库的更改操作 _init_.py为空文件，告诉python其为一个包 models.py用于储存应用的模型，即MVC中的M test.py一般用于放单元测试的代码 views.py用来放视图的函数 启动服务器 像pycharm直接点击运行按钮 也可以在终端输入 1python manage.py runserver 点击http://127.0.0.1:8000/ 就可以看见创建的服务了 编写一个页面","categories":[{"name":"Django","slug":"Django","permalink":"http://www.helicunzai.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"http://www.helicunzai.cn/tags/Django/"},{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"}]},{"title":"爬虫:推送川农大教务通知","slug":"爬虫-推送川农大教务通知","date":"2022-10-09T04:16:08.000Z","updated":"2022-10-09T07:44:27.520Z","comments":true,"path":"2022/10/09/爬虫-推送川农大教务通知/","link":"","permalink":"http://www.helicunzai.cn/2022/10/09/%E7%88%AC%E8%99%AB-%E6%8E%A8%E9%80%81%E5%B7%9D%E5%86%9C%E5%A4%A7%E6%95%99%E5%8A%A1%E9%80%9A%E7%9F%A5/","excerpt":"","text":"实现过程 平台 pushplus这个平台直接调用api接口就行了 目标网站 研究一下网页源代码的组成部分我们可以发现每个通知的xpath 1/html/body/form/div/div[2]/table/tbody/tr 我们获取到每个通知的url后，将它们放入集合中，后用json保存，一定时间再次爬取， 对前后两次集合的并集后取原集合的差集，如果结果不为空，则分别获取集合的结果，分页爬取文章内容 在调用平台API，发送信息 为了实现全部自动化，我们可以将脚本部署到服务器上定时运行，当注意教务网每天凌晨要关闭 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100from lxml import etreeimport requestsimport jsondef get_page(url): header = &#123; &quot;accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;, &quot;accept-encoding&quot;: &quot;gzip, deflate, br&quot;, &quot;accept-language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&quot;, &quot;referer&quot;: &quot;https://jiaowu.sicau.edu.cn/web/web/web/index.asp&quot;, &quot;sec-ch-ua&quot;: &#x27;Chromium&quot;;v=&quot;106&quot;, &quot;Microsoft Edge&quot;;v=&quot;106&quot;, &quot;Not;A=Brand&quot;;v=&quot;99&quot;&#x27;, &quot;sec-ch-ua-mobile&quot;: &quot;?0&quot;, &quot;sec-ch-ua-platform&quot;: &quot;Windows&quot;, &quot;sec-fetch-dest&quot;: &quot;document&quot;, &quot;sec-fetch-mode&quot;: &quot;navigate&quot;, &quot;sec-fetch-site&quot;: &quot;same-origin&quot;, &quot;sec-fetch-user&quot;: &quot;?1&quot;, &quot;upgrade-insecure-requests&quot;: &quot;1&quot;, &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 Edg/106.0.1370.37&quot; &#125; s = requests.get(url, headers=header) html = etree.HTML(s.content.decode(&#x27;gbk&#x27;)) title=html.xpath(&quot;/html/body/div[@class=&#x27;page-title-2&#x27;]/text()&quot;) txt=html.xpath(&quot;//table[@align=&#x27;center&#x27;]/tbody/tr/td/table&quot;) txt=etree.tostring(txt[2],encoding=&#x27;utf-8&#x27;).decode(&#x27;utf-8&#x27;) txt = &quot;&lt;head&gt;&lt;base href=\\&quot;&quot; + url + &quot;\\&quot; /&gt;&lt;/head&gt;&lt;p&gt;&lt;a href=\\&quot;&quot;+url+&quot;\\&quot;&gt;&quot;+title[0]+&quot;&lt;/a&gt;&lt;/p&gt;&quot;+txt return title,txtdef vx_msg(title,content): token = &#x27;平台token&#x27; url = &#x27;http://www.pushplus.plus/send&#x27; data = &#123; &quot;token&quot;: token, &quot;title&quot;: title, &quot;content&quot;: content &#125; body = json.dumps(data).encode(encoding=&#x27;utf-8&#x27;) headers = &#123;&#x27;Content-Type&#x27;: &#x27;application/json&#x27;&#125; r=requests.post(url, data=body, headers=headers) j=r.json() if j[&quot;code&quot;]==200: print(&quot;发送成功&quot;) else: print(&quot;失败&quot;)def get_data(): header = &#123; &quot;accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;, &quot;accept-encoding&quot;: &quot;gzip, deflate, br&quot;, &quot;accept-language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&quot;, &quot;referer&quot;: &quot;https://jiaowu.sicau.edu.cn/web/web/web/index.asp&quot;, &quot;sec-ch-ua&quot;: &#x27;Chromium&quot;;v=&quot;106&quot;, &quot;Microsoft Edge&quot;;v=&quot;106&quot;, &quot;Not;A=Brand&quot;;v=&quot;99&quot;&#x27;, &quot;sec-ch-ua-mobile&quot;: &quot;?0&quot;, &quot;sec-ch-ua-platform&quot;: &quot;Windows&quot;, &quot;sec-fetch-dest&quot;: &quot;document&quot;, &quot;sec-fetch-mode&quot;: &quot;navigate&quot;, &quot;sec-fetch-site&quot;: &quot;same-origin&quot;, &quot;sec-fetch-user&quot;: &quot;?1&quot;, &quot;upgrade-insecure-requests&quot;: &quot;1&quot;, &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 Edg/106.0.1370.37&quot; &#125; try: s = requests.get(&quot;https://jiaowu.sicau.edu.cn/web/web/web/gwmore.asp&quot;, headers=header) html = etree.HTML(s.content.decode(&#x27;gbk&#x27;)) result = html.xpath(&quot;/html/body/form/div/div[2]/table/tbody/tr&quot;) ls =set() for i in result: #date = i.xpath(&quot;./td[4]/text()&quot;) url = &quot;https://jiaowu.sicau.edu.cn/web/web/web/&quot; + &quot;&quot;.join(i.xpath(&quot;./td[3]/div/a/@href&quot;)) #title = i.xpath(&quot;./td[3]/div/a/font/text()&quot;) ls.add(url) return ls except: print(&quot;获取通知列表失败&quot;)def send(url): title, content = get_page(url) vx_msg(title[0], content)def read(): with open(&#x27;data.json&#x27;, &#x27;r&#x27;) as file: str = file.read() data = json.loads(str) return set(data)def save(data): with open(&#x27;data.json&#x27;, &#x27;w&#x27;) as file: str = file.write(json.dumps(data))try: ls=get_data() data=read() s=data|ls s=s-data if len(s)!=0: for i in s: print(i) send(i) save(list(ls)) else: print(&quot;没有新的通知&quot;)except: print(&quot;爬取失败&quot;)","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Requests:登录课程平台","slug":"Requests-登录课程平台","date":"2022-10-07T02:48:02.000Z","updated":"2022-10-07T02:48:02.947Z","comments":true,"path":"2022/10/07/Requests-登录课程平台/","link":"","permalink":"http://www.helicunzai.cn/2022/10/07/Requests-%E7%99%BB%E5%BD%95%E8%AF%BE%E7%A8%8B%E5%B9%B3%E5%8F%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"selenium:川农学工网自动化登录","slug":"selenium-川农学工网自动化登录","date":"2022-10-06T05:23:32.000Z","updated":"2022-10-09T07:16:46.587Z","comments":true,"path":"2022/10/06/selenium-川农学工网自动化登录/","link":"","permalink":"http://www.helicunzai.cn/2022/10/06/selenium-%E5%B7%9D%E5%86%9C%E5%AD%A6%E5%B7%A5%E7%BD%91%E8%87%AA%E5%8A%A8%E5%8C%96%E7%99%BB%E5%BD%95/","excerpt":"","text":"实现步骤 我萌使用检查工具查看相应的代码 同理我们知道了相应的html代码 验证码使用截屏方式截图后二值化处理后，进行OCR识别，如果错误，重复识别 ，如果密码错误，则退出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import tesserocrimport osimport timeimport reimport tesserocrfrom selenium import webdriverfrom io import BytesIOfrom PIL import Imagefrom retrying import retryimport matplotlib.pyplot as pltimport numpy as npimport matplotlib.pyplot as pltfrom PIL import Imagefrom selenium.webdriver.support.wait import WebDriverWaitfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.common.exceptions import TimeoutException,NoSuchElementExceptiondef preprocess(image): array =image array = np.where(image &gt; 100, 255, 0) image = Image.fromarray(array.astype(&#x27;uint8&#x27;)) return imagedef login(browser): username = &quot;user&quot; psw = &quot;psw&quot; browser.get(&quot;http://xsc.sicau.edu.cn/Sys/UserLogin.aspx&quot;) input = browser.find_element(By.ID, value=&#x27;UserName&#x27;) input.send_keys(username) input = browser.find_element(By.NAME, value=&#x27;UserPass&#x27;) input.send_keys(psw) browser.set_window_size(1000, 800) browser.save_screenshot(&#x27;1.png&#x27;) image = Image.open(&#x27;1.png&#x27;) image = image.convert(&#x27;RGB&#x27;) image = np.array(image) image = image[480:503, 1030:1103, :] image = preprocess(image) image = image.convert(&#x27;L&#x27;) plt.imshow(image) plt.show() code = tesserocr.image_to_text(image) code = code.strip() print(&quot;验证码识别结果&quot;, code) if code.isdigit(): input = browser.find_element(By.ID, value=&#x27;CheckCode&#x27;) code = str(code) input.send_keys(code) input = browser.find_element(By.ID, value=&#x27;CheckCode&#x27;) input.send_keys(code) input = browser.find_element(By.ID, value=&#x27;Btn_OK&#x27;) input.click() wait=WebDriverWait(browser,1) try: input=wait.until(EC.alert_is_present()) dig_alert = browser.switch_to.alert if(dig_alert.text==&quot;用户名或密码错误！&quot;): print(&quot;用户名或密码错误&quot;) return -1 dig_alert.accept() print(&quot;验证码失败了&quot;) return 0 except: return 1 else: print(&quot;识别有错&quot;) return 0if __name__ == &quot;__main__&quot;: browser = webdriver.Edge() browser.start_client() for i in range(5): p=login(browser) if p==1: print(&quot;登录成功&quot;) break elif p==-1: break","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"爬虫：川农选课","slug":"爬虫：川农选课","date":"2022-10-05T12:06:28.000Z","updated":"2022-10-06T04:44:54.598Z","comments":true,"path":"2022/10/05/爬虫：川农选课/","link":"","permalink":"http://www.helicunzai.cn/2022/10/05/%E7%88%AC%E8%99%AB%EF%BC%9A%E5%B7%9D%E5%86%9C%E9%80%89%E8%AF%BE/","excerpt":"","text":"import time from selenium.webdriver.support.wait import WebDriverWait from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support import expected_conditions as EC browser=webdriver.Edge() try: browser.get(&quot;https://jiaowu.sicau.edu.cn/&quot;) input=browser.find_element(By.NAME,value='user') input.send_keys('202105930') input=browser.find_element(By.NAME,value='pwd') input.send_keys('05174436') input=browser.find_element(By.XPATH,value='//input[@value=&quot;S&quot;]') input.click() input = browser.find_element(By.NAME, value='pwd') print(input.location) input.send_keys(Keys.ENTER) except: print(&quot;error&quot;)","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Python爬虫:微博爬取","slug":"Python爬虫-微博爬取","date":"2022-10-05T03:33:41.000Z","updated":"2022-10-05T11:09:20.158Z","comments":true,"path":"2022/10/05/Python爬虫-微博爬取/","link":"","permalink":"http://www.helicunzai.cn/2022/10/05/Python%E7%88%AC%E8%99%AB-%E5%BE%AE%E5%8D%9A%E7%88%AC%E5%8F%96/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import requestsfrom urllib.parse import urlencodefrom pyquery import PyQuery as pqbase_url = &#x27;https://m.weibo.cn/api/container/getIndex?&#x27;headers = &#123; &#x27;Host&#x27;: &#x27;m.weibo.cn&#x27;, &#x27;Referer&#x27;: &#x27;https://m.weibo.cn/u/2830678474&#x27;, &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36 Edg/105.0.1343.53&#x27;, &#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;,&#125;max_page = 50def get_page(page): uid=&#x27;1679186305&#x27; containerid=&#x27;107603&#x27;+uid params = &#123; &#x27;type&#x27;: &#x27;uid&#x27;, &#x27;value&#x27;: uid, &#x27;containerid&#x27;:containerid, &#x27;page&#x27;: page &#125; url = base_url + urlencode(params) try: response = requests.get(url, headers=headers) if response.status_code == 200: return response.json() except requests.ConnectionError as e: print(&#x27;Error&#x27;, e.args)def parse_page(json): if json: items = json.get(&#x27;data&#x27;).get(&#x27;cards&#x27;) for item in items: item = item.get(&#x27;mblog&#x27;) weibo = &#123;&#125; weibo[&#x27;id&#x27;] = item.get(&#x27;id&#x27;) weibo[&#x27;text&#x27;] = pq(item.get(&#x27;text&#x27;)).text() weibo[&#x27;attitudes&#x27;] = item.get(&#x27;attitudes_count&#x27;) weibo[&#x27;comments&#x27;] = item.get(&#x27;comments_count&#x27;) weibo[&#x27;reposts&#x27;] = item.get(&#x27;reposts_count&#x27;) yield weiboif __name__ == &#x27;__main__&#x27;: for page in range(1, max_page + 1): json = get_page(page) results = parse_page(json) for result in results: print(result)","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Java:集合类","slug":"Java-集合类","date":"2022-10-01T14:48:46.000Z","updated":"2022-10-01T15:29:35.216Z","comments":true,"path":"2022/10/01/Java-集合类/","link":"","permalink":"http://www.helicunzai.cn/2022/10/01/Java-%E9%9B%86%E5%90%88%E7%B1%BB/","excerpt":"","text":"Set 1234567891011121314151617public interface Set&lt;E&gt; extends Collection&lt;E&gt;&#123; //基本操作 int size(); boolean isEmpty(); boolean contains(Objects element); boolean add(E element); boolean remove(Objects element); Iterator&lt;E&gt; iterator(); boolean containsAll(Collection &lt;?&gt; c); boolean addAll(Collection&lt;?extends E&gt; c);//将集合c的元素添加到本集合 boolean removeAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c);//只保留属于c的元素 void clear(); Objects[] toArray(); &lt;T&gt;T[] toArray(T[] a);&#125; JDK提供Set接口3个实用类 HashSet，采用Hash,无固定顺序 TreeSet，实现SortedSet接口，有序 LinkedHashSet，有固定顺序 List 1234567891011121314public interface List&lt;E&gt; extends Collection&lt;E&gt;&#123; E get(int index); E set(int index,E element); boolean add(E element); void add(int index,E element); E remove(int index); boolean addAll(int index,Collection&lt;? extends E&gt; c); //查找 int indexOf(Object o); int lastIndexOf(Object o); ListIterator&lt;E&gt; listIterator(); ListIterator&lt;E&gt; listIterator(int index); Lis&lt;E&gt; subList(int from,int to);&#125; JDK提供Set接口3个实用类 ArrayList,效率最高 LinkedList,还提供在结尾和开头get,remove,insert Vector Queue 12345678public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; E element(); boolean add(E e); boolean offer(E e); E remove(); E poll(); E peek();&#125; Map 1234567891011121314151617181920public interface Map&lt;K, V&gt; &#123; int size(); V put(K key,V value); V get(Object key); V remove(Object key); boolean containsKey(Object key); boolean containsValue(Object value); int size(); boolean isEmpty(); void putAll(Map&lt;?extends K,?extends V&gt;m); void clear(); public Set(K) keySet(); public Collection&lt;V&gt; values(); public Set&lt;Map.Entry&lt;k,v&gt;&gt; entrySet(); public interface Entry&#123; K getKey(); V getValue(); V setValue(V value); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://www.helicunzai.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.helicunzai.cn/tags/Java/"}]},{"title":"使用Python和NumPy构建神经网络模型","slug":"使用Python和NumPy构建神经网络模型","date":"2022-09-26T05:37:34.000Z","updated":"2022-10-14T15:56:49.861Z","comments":true,"path":"2022/09/26/使用Python和NumPy构建神经网络模型/","link":"","permalink":"http://www.helicunzai.cn/2022/09/26/%E4%BD%BF%E7%94%A8Python%E5%92%8CNumPy%E6%9E%84%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://www.helicunzai.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"人工智能","slug":"人工智能","permalink":"http://www.helicunzai.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}]},{"title":"Numpy笔记","slug":"Numpy笔记","date":"2022-09-26T04:11:57.000Z","updated":"2022-10-04T03:55:02.580Z","comments":true,"path":"2022/09/26/Numpy笔记/","link":"","permalink":"http://www.helicunzai.cn/2022/09/26/Numpy%E7%AC%94%E8%AE%B0/","excerpt":"","text":"安装 1pip3 install --user numpy scipy matplotlib Ndarray 对象 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。 1numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0) 参数说明： 名称 描述 object 数组或嵌套的数列 dtype 数组元素的数据类型，可选 copy 对象是否需要复制，可选 order 创建数组的样式，C为行方向，F为列方向，A为任意方向（默认） subok 默认返回一个与基类类型一致的数组 ndmin 指定生成数组的最小维度 123456import numpy as np a = np.array([1,2,3],ndmin = 2,dtype = complex,) print (a)/**/ 数据类型 名称 描述 bool_ 布尔型数据类型（True 或者 False） int_ 默认的整数类型（类似于 C 语言中的 long，int32 或 int64） intc 与 C 的 int 类型一样，一般是 int32 或 int 64 intp 用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64） int8 字节（-128 to 127） int16 整数（-32768 to 32767） int32 整数（-2147483648 to 2147483647） int64 整数（-9223372036854775808 to 9223372036854775807） uint8 无符号整数（0 to 255） uint16 无符号整数（0 to 65535） uint32 无符号整数（0 to 4294967295） uint64 无符号整数（0 to 18446744073709551615） float_ float64 类型的简写 float16 半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位 float32 单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位 float64 双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位 complex_ complex128 类型的简写，即 128 位复数 complex64 复数，表示双 32 位浮点数（实数部分和虚数部分） complex128 复数，表示双 64 位浮点数（实数部分和虚数部分） numpy 的数值类型实际上是 dtype 对象的实例，并对应唯一的字符，包括 np.bool_，np.int32，np.float32，等等。 数据类型对象 (dtype) 1numpy.dtype(object, align, copy) 1234import numpy as np# 使用标量类型dt = np.dtype(np.int32)print(dt) 123456import numpy as npdt = np.dtype([(&#x27;age&#x27;,np.int8)]) print(dt) /*[(&#x27;age&#x27;, &#x27;i1&#x27;)] */ 1234import numpy as npstudent = np.dtype([(&#x27;name&#x27;,&#x27;S20&#x27;), (&#x27;age&#x27;, &#x27;i1&#x27;), (&#x27;marks&#x27;, &#x27;f4&#x27;)]) a = np.array([(&#x27;abc&#x27;, 21, 50),(&#x27;xyz&#x27;, 18, 75)], dtype = student) print(a) 数组属性 属性 说明 ndarray.ndim 秩，即轴的数量或维度的数量 ndarray.shape 数组的维度，对于矩阵，n 行 m 列 ndarray.size 数组元素的总个数，相当于 .shape 中 n*m 的值 ndarray.dtype ndarray 对象的元素类型 ndarray.itemsize ndarray 对象中每个元素的大小，以字节为单位 ndarray.flags ndarray 对象的内存信息 ndarray.real ndarray元素的实部 ndarray.imag ndarray 元素的虚部 ndarray.data 包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性 创建数组 numpy.empty 1numpy.empty(shape, dtype = float, order = &#x27;C&#x27;) numpy.zeros 1numpy.zeros(shape, dtype = float, order = &#x27;C&#x27;) numpy.ones 1numpy.ones(shape, dtype = None, order = &#x27;C&#x27;) 从已有的数组创建数组 numpy.asarray 1numpy.asarray(a,dtype = None, order = None) 参数 描述 a 任意形式的输入参数，可以是，列表, 列表的元组, 元组, 元组的元组, 元组的列表，多维数组 dtype 数据类型，可选 order 可选，有&quot;C&quot;和&quot;F&quot;两个选项,分别代表，行优先和列优先，在计算机内存中的存储元素的顺序。 12345import numpy as np x = [1,2,3] a = np.asarray(x) print (a) numpy.frombuffer 1numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0) 1234import numpy as np s = b&#x27;Hello World&#x27; a = np.frombuffer(s, dtype = &#x27;S1&#x27;) print (a) numpy.fromiter 1numpy.fromiter(iterable, dtype, count=-1) 123456789import numpy as np # 使用 range 函数创建列表对象 list=range(5)it=iter(list)# 使用迭代器创建 ndarray x=np.fromiter(it, dtype=float)print(x) 从数值范围创建数组 numpy.arange 1numpy.arange(start, stop, step, dtype) numpy.linspace 1np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None) 参数 描述 start 序列的起始值 stop 序列的终止值，如果endpoint为true，该值包含于数列中 num 要生成的等步长的样本数量，默认为50 endpoint 该值为 true 时，数列中包含stop值，反之不包含，默认是True。 retstep 如果为 True 时，生成的数组中会显示间距，反之不显示。 dtype ndarray 的数据类型 numpy.logspace 1np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None) 参数 描述 start 序列的起始值为：base ** start stop 序列的终止值为：base ** stop。如果endpoint为true，该值包含于数列中 num 要生成的等步长的样本数量，默认为50 endpoint 该值为 true 时，数列中中包含stop值，反之不包含，默认是True。 base 对数 log 的底数。 dtype ndarray 的数据类型 切片和索引 12345678import numpy as npa = np.arange(10)s = slice(2,7,2) # 从索引 2 开始到索引 7 停止，间隔为2print (a[s]) /*[2 4 6]*/ 12345import numpy as npa = np.arange(10) b = a[2:7:2] # 从索引 2 开始到索引 7 停止，间隔为 2print(b) 切片还可以包括省略号 …，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。 123456import numpy as npa = np.array([[1,2,3],[3,4,5],[4,5,6]]) print (a[...,1]) # 第2列元素print (a[1,...]) # 第2行元素print (a[...,1:]) # 第2列及剩下的所有元素 高级索引 整数数组索引 12345import numpy as np #以下实例获取数组中 (0,0)，(1,1) 和 (2,0) 位置处的元素。x = np.array([[1, 2], [3, 4], [5, 6]]) y = x[[0,1,2], [0,1,0]] print (y) 布尔索引 123456789import numpy as np x = np.array([[ 0, 1, 2],[ 3, 4, 5],[ 6, 7, 8],[ 9, 10, 11]]) print (&#x27;我们的数组是：&#x27;)print (x)print (&#x27;\\n&#x27;)# 现在我们会打印出大于 5 的元素 print (&#x27;大于 5 的元素是：&#x27;)print (x[x &gt; 5]) 花式索引 1234567891011mport numpy as npx = np.arange(9)print(x)# 一维数组读取指定下标对应的元素print(&quot;-------读取下标对应的元素-------&quot;)x2 = x[[0, 6]] # 使用花式索引print(x2)print(x2[0])print(x2[1]) 1234567import numpy as np x=np.arange(32).reshape((8,4))print(x)# 二维数组读取指定下标对应的行print(&quot;-------读取下标对应的行-------&quot;)print (x[[4,2,1,7]]) 广播(Broadcast) 123456789import numpy as np a = np.array([1,2,3,4]) b = np.array([10,20,30,40]) c = a * b print (c) /*[ 10 40 90 160]*/ 迭代数组 1234567891011121314151617import numpy as npa = np.arange(6).reshape(2,3)print (&#x27;原始数组是：&#x27;)print (a)print (&#x27;\\n&#x27;)print (&#x27;迭代输出元素：&#x27;)for x in np.nditer(a): print (x, end=&quot;, &quot; )print (&#x27;\\n&#x27;) /*原始数组是：[[0 1 2] [3 4 5]]迭代输出元素：0, 1, 2, 3, 4, 5, */ 控制遍历顺序 for x in np.nditer(a, order='F'):Fortran order，即是列序优先； for x in np.nditer(a.T, order='C'):C order，即是行序优先； 数组操作 函数 描述 reshape 不改变数据的条件下修改形状 flat 数组元素迭代器 flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组 ravel 返回展开数组 修改数组形状 numpy.reshape 1numpy.reshape(arr, newshape, order=&#x27;C&#x27;) numpy.ndarray.flat 1234567891011import numpy as npa = np.arange(9).reshape(3,3) print (&#x27;原始数组：&#x27;)for row in a: print (row)#对数组中每个元素都进行处理，可以使用flat属性，该属性是一个数组元素迭代器：print (&#x27;迭代后的数组：&#x27;)for element in a.flat: print (element) numpy.ndarray.flatten numpy.ndarray.flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组，格式如下： 1ndarray.flatten(order=&#x27;C&#x27;) numpy.ravel 1numpy.ravel(a, order=&#x27;C&#x27;) 翻转数组 函数 描述 transpose 对换数组的维度 ndarray.T 和 self.transpose() 相同 rollaxis 向后滚动指定的轴 swapaxes 对换数组的两个轴 numpy.transpose numpy.transpose 函数用于对换数组的维度，格式如下： 1numpy.transpose(arr, axes) numpy.rollaxis numpy.rollaxis 函数向后滚动特定的轴到一个特定位置，格式如下： 1numpy.rollaxis(arr, axis, start) numpy.swapaxes numpy.swapaxes 函数用于交换数组的两个轴，格式如下： 1numpy.swapaxes(arr, axis1, axis2) 随机ndarray数组 创建随机ndarray数组主要包含设置随机种子、均匀分布和正态分布三部分内容 设置随机数种子 1234# 可以多次运行，观察程序输出结果是否一致# 如果不设置随机数种子，观察多次运行输出结果是否一致np.random.seed(10)a = np.random.rand(3, 3) 均匀分布 12# 生成均匀分布随机数，随机数取值范围在[0, 1)之间a = np.random.rand(3, 3) 生成均匀分布随机数，指定随机数取值范围和数组形状 a = np.random.uniform(low = -1.0, high = 1.0, size=(2,2)) 12345678910```- **正态分布**```python# 生成标准正态分布随机数a = np.random.randn(3, 3)a = np.random.normal(loc = 1.0, scale = 1.0, size = (3,3))","categories":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"}]},{"title":"STM32F1软件仿真","slug":"STM32F1软件仿真","date":"2022-09-22T16:05:35.000Z","updated":"2022-10-15T16:20:50.818Z","comments":true,"path":"2022/09/23/STM32F1软件仿真/","link":"","permalink":"http://www.helicunzai.cn/2022/09/23/STM32F1%E8%BD%AF%E4%BB%B6%E4%BB%BF%E7%9C%9F/","excerpt":"","text":"MDK 的一个强大的功能就是提供软件仿真，通过软件仿真，我们可以发现很多将要出现 的问题，避免了下载到 STM32 里面来查这些错误，这样最大的好处是能很方便的检查程序存 在的问题，因为在 MDK 的仿真下面，你可以查看很多硬件相关的寄存器，通过观察这些寄存 器，你可以知道代码是不是真正有效。另外一个优点是不必频繁的刷机，从而延长了 STM32 的 FLASH 寿命（STM32 的 FLASH 寿命≥1W 次）。当然，软件仿真不是万能的，很多问题还 是要到在线调试才能发现。 检查配置 如下图 Debug 选项卡 Use Simulator，即使用软件仿真。选择：Run to main()，即跳过汇 编代码，直接跳转到 main 函数开始仿真。设置下方的：Dialog DLL 分别为：***DARMSTM.DLL **** 和 TARMSTM.DLL， Parameter 均为： -pSTM32F103ZE ，用于设置支持 STM32F103ZE 的软硬件仿真（即可以通过Peripherals 选择对应外设的对话框观察仿真结果）。最后点击 OK，完成设置。 开始仿真 我们点击开始仿真,进入仿真界面 Debug工具条 复位：相当于硬件复位按键，从头开始 执行到断点处：该按钮用来快速执行到断点处 挂起：可以使程序停止下来， 进入到单步调试状态 执行进去：实现执行到某个函数里面去的功能，在没有函数的情况下，是等同于执行过去按钮的 执行过去：在碰到有函数的地方，通过该按钮就可以单步执行过这个函数，而不进入这个函数单步执行 执行出去：该按钮是在进入了函数单步调试的时候，有时候你可能不必再执行该函数的剩余部分了，通过该按钮就直接一步执行完函数余下的部分，并跳出函数，回到函数被调用的位置。 执行到光标处：可以迅速的使程序运行到光标处，其实是挺像执行到断点处按钮功能，但是两者是有区别的，断点可以有多个，但是光标所在处只有一个。 汇编窗口：可以查看汇编代码，这对分析程序很有用。 观看变量/堆栈窗口：显示变量的窗口，在里面可以查看各种你想要看的变量值，也是很常用的一个调试窗口。 性能分析窗口：观看各个函数执行时间和所占百分比的窗口，用来分析函数的性能 逻辑分析窗口：按下该按钮会弹出一个逻辑分析窗口，通过 SETUP 按钮新建一些 IO 口，就可以观察这些 IO 口的电平变化情况，以多种形式显示出来，比较直观。","categories":[{"name":"STM32","slug":"STM32","permalink":"http://www.helicunzai.cn/categories/STM32/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://www.helicunzai.cn/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"STM32","slug":"STM32","permalink":"http://www.helicunzai.cn/tags/STM32/"}]},{"title":"STM32固件库","slug":"STM32固件库","date":"2022-09-21T07:42:54.000Z","updated":"2022-10-09T07:23:18.373Z","comments":true,"path":"2022/09/21/STM32固件库/","link":"","permalink":"http://www.helicunzai.cn/2022/09/21/STM32%E5%9B%BA%E4%BB%B6%E5%BA%93/","excerpt":"","text":"什么是固件库？ STM32 固件库就是函数的集合 为了能让不同的芯片公司生产的 Cortex-M3 芯片能在软件上基本兼容，和芯片生产商共同提出了一套标准 CMSIS 标准(Cortex Microcontroller Software Interface Standard) ,翻译过来是“ARM Cortex™ 微控制器软件接口标准”。 CMSIS 分为 3 个基本功能层： 核内外设访问层：ARM 公司提供的访问，定义处理器内部寄存器地址以及功能函数。 中间件访问层:定义访问中间件的通用 API,也是 ARM 公司提供。 外设访问层：定义硬件寄存器的地址以及外设的访问函数。 CMSIS 层在整个系统中是处于中间层，向下负责与内核和各个外设直接打交道，向上提供实时操作系统用户程序调用的函数接口。如果没有 CMSIS 标准，那么各个芯片公司就会设计自己喜欢的风格的库函数，而 CMSIS 标准就是要强制规定，芯片生产公司设计的库 函数必须按照 CMSIS 这套规范来设计。 新建基于固件库的 MDK5 工程模板 建立一个文件夹,并在其下新建USER目录 keil5新建项目在USER下 删除USER下的objects和Listings 在根目录下新建CORE,OBJ，以及LIB文件夹 STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\STM32F10x_StdPeriph_Driver 下面， 将目录下面的* src,inc 文件夹 *复制 到我们刚才建立的 STM32F10x_FWLib 文件夹下面。 目录STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\CoreSupport 下面，将文件 core_cm3.c、core_cm3.h 复制到 CORE 下 面 去 。 *STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\DeviceSupport\\ST\\STM32F10x\\startup\\arm *下面，将里面 startup_stm32f10x_hd.s 文件复制到 CORE 下面。 定位为STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\DeviceSupport\\ST\\STM32F10x将里面的三个文件stm32f10x.h，system_stm32f10x.c，system_stm32f10x.h，复制到我们的 USER目录之下。 定位于STM32F10x_StdPeriph_Lib_V3.5.0\\Project\\STM32F10x_StdPeriph_Template 下面的 4 个 文件main.c，stm32f10x_conf.h，stm32f10x_it.c，stm32f10x_it.h 复制到 USER 目录下面 下面我们将这些文件加入我们的工程中去。右键点击 Target1，选择 Manage Components Project Targets 一栏，我们将 Target 名字修改为 Template,然后在 Groups 一栏删掉一个 Source Group1，建立三个 Groups：USER,CORE,FWLIB。然后点击 OK，可以看到我们的 Target名字以及 Groups 情况。 选择选择 Manage Components.然后选择需要添加文件的 Group，这里第一步我们选 择 FWLIB ， 然 后 点 击 右 边 的 Add Files, 定 位 到 我 们 刚 才 建 立 的 目 录STM32F10x_FWLib/src 下面，将里面所有的文件选中(Ctrl+A)，然后点击 Add，然后 Close.可以看到 Files 列表下面包含我们添加的文件。 将 Groups 定位到 CORE 和 USER 下面，添加需要的文件。这里我们的 CORE 下面需要添加的文件为 core_cm3.c，startup_stm32f10x_hd.s USER 目录下面需要添加的文件为 main.c，stm32f10x_it.c，system_stm32f10x.c. 接下来我们要编译工程，在编译之前我们首先要选择编译中间文件编译后存放目录。 方法是点击魔术棒，然后选择“Output”选项下面的“Select folder for objects…”,然后选 择目录为我们上面新建的 OBJ 目录。这里大家注意，如果我们不设置 Output 路径，那么默认的编译中间文件存放目录就是 MDK 自动生成的 Objects 目录和 Listings 目录 对于任何一个工程，我们都需要把工程中引用到的所有头文件的路径都包含到进来。回到工程主菜单，点击魔术棒 ，出来一个菜单，然后点击 c/c++选项.然后点击 Include Paths 右边的按钮。弹出一个添加 path 的对话框，然后我们将图上面的 3 个目录添加进去。记住，keil 只会在一级目录查找，所以如果你的目录下面还有子目录，记得 path一定要定位到最后一级子目录。然后点击 OK 将正点原子的SYSTEM文件将.c和.h文件导入项目 本文源文件下载","categories":[{"name":"STM32","slug":"STM32","permalink":"http://www.helicunzai.cn/categories/STM32/"}],"tags":[{"name":"嵌入式","slug":"嵌入式","permalink":"http://www.helicunzai.cn/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"STM32","slug":"STM32","permalink":"http://www.helicunzai.cn/tags/STM32/"}]},{"title":"OpenCV:灰度变换和直方图修正","slug":"灰度变换和直方图修正","date":"2022-09-16T13:56:28.000Z","updated":"2022-10-09T07:46:44.016Z","comments":true,"path":"2022/09/16/灰度变换和直方图修正/","link":"","permalink":"http://www.helicunzai.cn/2022/09/16/%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2%E5%92%8C%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%BF%AE%E6%AD%A3/","excerpt":"","text":"灰度化 加权平均值实现 12345678910111213import cv2 as cvimport numpy as npimage=cv.imread(&quot;pic.png&quot;)h=np.shape(image)[0]w=np.shape(image)[1]gray_img=np.zeros((h,w,3),np.uint8)for i in range(h): for j in range(w): gray_img[i,j]=0.3*image[i,j][0]+0.59*image[i,j][1]+0.11*image[i,j][2]cv.imshow(&quot;src&quot;,image)cv.imshow(&quot;gray&quot;,gray_img)cv.waitKey(0)cv.destroyAllWindows() 最大法实现 12345678910111213 import cv2 as cvimport numpy as npimage=cv.imread(&quot;pic.png&quot;)h=np.shape(image)[0]w=np.shape(image)[1]gray_img=np.zeros((h,w,3),np.uint8)for i in range(h): for j in range(w): gray_img[i,j]=max(image[i,j][0],image[i,j][1],image[i,j][2])cv.imshow(&quot;src&quot;,image)cv.imshow(&quot;gray&quot;,gray_img)cv.waitKey(0)cv.destroyAllWindows() 平均法实现 12345678910111213import cv2 as cvimport numpy as npimage=cv.imread(&quot;pic.png&quot;)h=np.shape(image)[0]w=np.shape(image)[1]gray_img=np.zeros((h,w,3),np.uint8)for i in range(h): for j in range(w): gray_img[i,j]=(image[i,j][0]+image[i,j][1]+image[i,j][2])/3cv.imshow(&quot;src&quot;,image)cv.imshow(&quot;gray&quot;,gray_img)cv.waitKey(0)cv.destroyAllWindows() 灰度线性变换 1234567891011import cv2 as cvimport numpy as npimg=cv.imread(&quot;pic.png&quot;)out=1.8*imgout[out&gt;255]=255out=np.around(out)out=out.astype(np.uint8)cv.imshow(&quot;img&quot;,img)cv.imshow(&quot;out&quot;,out)cv.waitKey(0)cv.destroyAllWindows() 分段线性变换 1","categories":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.helicunzai.cn/categories/OpenCV/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.helicunzai.cn/tags/OpenCV/"}]},{"title":"OpenCV:图像处理","slug":"OpenCV-图像处理","date":"2022-09-12T08:55:06.000Z","updated":"2022-09-16T13:59:33.660Z","comments":true,"path":"2022/09/12/OpenCV-图像处理/","link":"","permalink":"http://www.helicunzai.cn/2022/09/12/OpenCV-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/","excerpt":"","text":"颜色变换cvtColor 1234567891011import cv2img=cv2.imread(&#x27;pic.png&#x27;)gray_img=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)hsv_img=cv2.cvtColor(img,cv2.COLOR_BGR2HSV)rgb=cv2.cvtColor(img,cv2.COLOR_BGR2RGB)cv2.imshow(&quot;img&quot;,img)cv2.imshow(&quot;gray&quot;,gray_img)cv2.imshow(&quot;hsv&quot;,hsv_img)cv2.imshow(&quot;RGB&quot;,rgb)cv2.waitKey(0)cv2.destroyWindow() 画基本图形 画矩形 1def rectangle(img, pt1, pt2, color, thickness=None, lineType=None, shift=None): 123456import cv2img=cv2.imread(&#x27;pic.png&#x27;)img=cv2.rectangle(img,(100,100),(300,400),(255,14,65),6)cv2.imshow(&quot;1&quot;,img)cv2.waitKey(0)cv2.destroyWindow() 画圆 1def circle(img, center, radius, color, thickness=None, lineType=None, shift=None): 123456import cv2img=cv2.imread(&#x27;pic.png&#x27;)img=cv2.circle(img,(300,200),100,(155,64,240),-1)cv2.imshow(&quot;1&quot;,img)cv2.waitKey(0)cv2.destroyWindow() 画椭圆 1def ellipse(img, center, axes, angle, startAngle, endAngle, color, thickness=None, lineType=None, shift=None): 123456import cv2img=cv2.imread(&#x27;pic.png&#x27;)img=cv2.ellipse(img,(100,200),(50,20),0,0,360,(255,0,0),-1,8)cv2.imshow(&quot;1&quot;,img)cv2.waitKey(0)cv2.destroyWindow() 画线段 1def line(img, pt1, pt2, color, thickness=None, lineType=None, shift=None): 12345678import cv2import numpy as npimg=cv2.imread(&#x27;pic.png&#x27;)Pts=np.array([[10,5],[20,30],[70,20],[50,10]],np.int32)img=cv2.line(img,[0,0],[300,200],(0,0,255),2)cv2.imshow(&quot;1&quot;,img)cv2.waitKey(0)cv2.destroyWindow() 画多边形 1def polylines(img, pts, isClosed, color, thickness=None, lineType=None, shift=None): 12345678import cv2import numpy as npimg=cv2.imread(&#x27;pic.png&#x27;)Pts=np.array([[10,5],[20,30],[70,20],[50,10]],np.int32)img=cv2.polylines(img,[Pts],True,(255,0,0),6)cv2.imshow(&quot;1&quot;,img)cv2.waitKey(0)cv2.destroyWindow() 填充多边形 1def fillPoly(img, pts, color, lineType=None, shift=None, offset=None): 12345678import cv2import numpy as npimg=cv2.imread(&#x27;pic.png&#x27;)Pts=np.array([[10,5],[20,30],[70,20],[50,10]],np.int32)img=cv2.fillPoly(img,[Pts],(255,0,0))cv2.imshow(&quot;1&quot;,img)cv2.waitKey(0)cv2.destroyWindow()","categories":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.helicunzai.cn/tags/OpenCV/"}]},{"title":"OpenCV:数组矩阵","slug":"OpenCV-数组矩阵","date":"2022-09-11T03:43:37.000Z","updated":"2022-09-12T09:26:32.118Z","comments":true,"path":"2022/09/11/OpenCV-数组矩阵/","link":"","permalink":"http://www.helicunzai.cn/2022/09/11/OpenCV-%E6%95%B0%E7%BB%84%E7%9F%A9%E9%98%B5/","excerpt":"","text":"ndarray对象 1def array(p_object, dtype=None, *args, **kwargs): 1a=np.array([1,2,3],ndmin=2) 1a=np.array([1,2,3],dtype=complex) NumPy数据类型 名称 描述 bool_ 布尔型数据类型（True 或者 False） int_ 默认的整数类型（类似于 C 语言中的 long，int32 或 int64） intc 与 C 的 int 类型一样，一般是 int32 或 int 64 intp 用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64） int8 字节（-128 to 127） int16 整数（-32768 to 32767） int32 整数（-2147483648 to 2147483647） int64 整数（-9223372036854775808 to 9223372036854775807） uint8 无符号整数（0 to 255） uint16 无符号整数（0 to 65535） uint32 无符号整数（0 to 4294967295） uint64 无符号整数（0 to 18446744073709551615） float_ float64 类型的简写 float16 半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位 float32 单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位 float64 双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位 complex_ complex128 类型的简写，即 128 位复数 complex64 复数，表示双 32 位浮点数（实数部分和虚数部分） complex128 复数，表示双 64 位浮点数（实数部分和虚数部分） numpy 的数值类型实际上是 dtype 对象的实例，并对应唯一的字符，包括 np.bool_，np.int32，np.float32，等等。 新建数组 12x=np.empty([3],dtype=int)print(x) 为随机值，未初始化 12x=np.zeros([3,2],dtype=int)print(x) 12x=np.ones([3,2],dtype=int)print(x) 从已有的数组创建数组 1234import numpy as npx=[[1,2,3],[2,3,2]]a=np.asarray(x)print(a.shape) 1234import numpy as npstr=b&#x27;hello&#x27;a=np.frombuffer(str,dtype=&#x27;S1&#x27;)print(a) 12345import numpy as nplist=range(20)it=iter(list)x=np.fromiter(it,dtype=int)print(x) 从数值范围创建数组 12x=np.arange(12,dtype=float)print(x) 123import numpy as npx=np.linspace(0,9,10,dtype=int)print(x) 123import numpy as npx=np.logspace(0,9,10,base=2)print(x) 切片与索引 1234import numpy as npx=np.arange(15)a=slice(2,10,3)print(x[a]) 1234import numpy as npx=np.arange(15)a=x[2:12:3]print(a) 12345import numpy as npx=np.array([[1,2,3],[4,5,6],[7,8,9]])print(x[...,1])#第二列print(x[1,...])#第二行print(x[...,1:])#第二列及以下 高级索引 整数数组索引 12345678import numpy as np#获取(0,0),(1,1),(2,0)x=np.array([[1,2],[3,4],[5,6]])y=x[[0,1,2],[0,1,0]]print(y) /*[1 4 5]*/ 布尔索引 1234567import numpy as npx=np.arange(1,50)print(x[x&gt;10]) /*[11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49]*/ 花式索引 12345678import numpy as npx=np.arange(32).reshape(4,8)print(x[[0,2,1]]) /*[[ 0 1 2 3 4 5 6 7] [16 17 18 19 20 21 22 23] [ 8 9 10 11 12 13 14 15]]*/ 迭代数组 迭代对象nditer 1234import numpy as npx=np.arange(6).reshape(3,2)for i in np.nditer(x): print(i,end=&quot;,&quot;) 控制遍历顺序 1234567import numpy as npx=np.arange(6).reshape(3,2)for i in np.nditer(x,order=&#x27;F&#x27;): print(i,end=&quot;,&quot;) /*0,2,4,1,3,5,*/ 1234567import numpy as npx=np.arange(6).reshape(3,2)for i in np.nditer(x,order=&#x27;C&#x27;): print(i,end=&quot;,&quot;) /*0,1,2,3,4,5,*/ 修改数组中元素的值 123456import numpy as npx=np.arange(0,60,5).reshape(3,4)print(x)for i in np.nditer(x,op_flags=[&#x27;readwrite&#x27;]): i[...]=2*iprint(x) 使用外部循环 1234567import numpy as npx=np.arange(0,60,5).reshape(3,4)for i in np.nditer(x,flags=[&#x27;external_loop&#x27;],order=&#x27;F&#x27;): print(i,end=&#x27;,&#x27;) /*[ 0 20 40],[ 5 25 45],[10 30 50],[15 35 55],*/ 广播迭代 12345import numpy as npx=np.arange(0,60,5).reshape(3,4)b=np.array([1,2,3,4],dtype=int)for i,j in np.nditer([x,b]): print(i,j) 数组操作 修改数组形状 12345import numpy as npx=np.arange(0,60,5).reshape(3,4)print(x)for j in x.flat: print(j,end=&quot; &quot;) 反转数组 123import numpy as npx=np.arange(0,60,5).reshape(3,4)print(np.transpose(x))","categories":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.helicunzai.cn/categories/OpenCV/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.helicunzai.cn/tags/OpenCV/"}]},{"title":"OpenCV的基本操作","slug":"OpenCV的基本操作","date":"2022-09-10T03:40:54.000Z","updated":"2022-10-09T07:32:40.571Z","comments":true,"path":"2022/09/10/OpenCV的基本操作/","link":"","permalink":"http://www.helicunzai.cn/2022/09/10/OpenCV%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"图像输入输出模块imgcodecs 读取图像文件 读取图片 1cv2.imread(path[, flag]) 第二个参数指定图片被读取的方式： cv2.IMREAD_COLOR : 读入彩色图像，默认模式； cv2.IMREAD_GRAYSCALE : 以灰度模式读入图像； cv2.IMREAD_UNCHANGED : 加载图像包含alpha通道。 使用数字简约表示以上三种标记，分别为 1， 0或-1。 123import cv2image_path = &quot;images.jpg&quot;img = cv2.imread(image_path,0) 读取失败返回None 读取照片的高度与宽度 1234567891011import cv2 as cvimport numpy as npimg=cv.imread(&#x27;pic.png&#x27;)print(np.shape(img))height=np.shape(img)[0]width=np.shape(img)[1]channles=np.shape(img)[2]print(&quot;height:&quot;,height)print(&#x27;width:&#x27;,width)print(&#x27;channles:&#x27;,channles) 保存照片 1imwrite(filename,img[,params)-&gt;retval 12345678910import cv2 as cvimport numpy as npimg=cv.imread(&#x27;pic.png&#x27;)height,width=img.shape[:2]cv.line(img,(0,0),(width,height),(0,0,255),1)cv.imwrite(&#x27;output.jpg&#x27;,img)img=cv.imread(&#x27;output.jpg&#x27;)cv.imshow(&#x27;img&#x27;,img)cv.waitKey(0)cv.destroyAllWindows() OpenCV界面编程 新建窗口函数 1namedWindow(winname[,flags]) flags cv2.WINDOW_AUTOSIZE 窗口大小自动适应 cv2.WINDOW_NORMAL 1234567import cv2 as cvimport numpy as npimg=cv.imread(&#x27;pic.png&#x27;)cv.namedWindow(&#x27;hemo&#x27;,cv.WINDOW_NORMAL)cv.imshow(&#x27;hemo&#x27;,img)cv.waitKey(6000)cv.destroyAllWindows() 单窗口显示多图片 利用numpy的hstack函数合并行数相同的矩阵数组 12345678import cv2 as cvimport numpy as npimg1=cv.imread(&#x27;pic.png&#x27;)img2=cv.imread(&#x27;pic2.png&#x27;)img=np.hstack([img1,img2])cv.imshow(&#x27;a&#x27;,img)cv.waitKey(0)cv.destroyAllWindows() 销毁窗口 cv2.destroyWindow(winname) cv2.destroyAllWindows(winname) cv2.resizeWindow(winname,width,height) 1234567891011import cv2 as cvimport numpy as npimg1=cv.imread(&#x27;pic.png&#x27;)img2=cv.imread(&#x27;pic2.png&#x27;)img=np.hstack([img1,img2])cv.namedWindow(&#x27;1&#x27;,cv.WINDOW_NORMAL)cv.imshow(&#x27;1&#x27;,img)cv.resizeWindow(&#x27;1&#x27;,900,300)cv.waitKey(0)cv.destroyAllWindows()cv.destroyWindow() 鼠标事件 OpenCV使用setMousecallback设定 1234//设置回调函数def setMouseCallback(windowName, onMouse, param=None)://回调函数void your_mouse_callback(int event,int x,int y,int flags,void* param) ; 鼠标事件event enum { EVENT_MOUSEMOVE =0, //鼠标移动 EVENT_LBUTTONDOWN =1, //按下左键 EVENT_RBUTTONDOWN =2, //按下右键 EVENT_MBUTTONDOWN =3, //按下中键 EVENT_LBUTTONUP =4, //放开左键 EVENT_RBUTTONUP =5, //放开右键 EVENT_MBUTTONUP =6, //放开中键 EVENT_LBUTTONDBLCLK =7, //左键双击 EVENT_RBUTTONDBLCLK =8, //右键双击 EVENT_MBUTTONDBLCLK =9, //中键双击 EVENT_MOUSEWHEEL =10, //滚轮滚动 }; 鼠标事件flags enum { CV_EVENT_FLAG_LBUTTON =1, //左键拖拽 CV_EVENT_FLAG_RBUTTON =2, //右键拖拽 CV_EVENT_FLAG_MBUTTON =4, //中键拖拽 CV_EVENT_FLAG_CTRLKEY =8, //按住CTRL拖拽 CV_EVENT_FLAG_SHIFTKEY =16, //按住Shift拖拽 CV_EVENT_FLAG_ALTKEY =32 //按住ALT拖拽 }; 1234567891011121314151617import cv2 as cvimport numpy as npimg=np.zeros((400,400))def draw_circle(event,x,y,flags,param): if event==cv.EVENT_LBUTTONDOWN: cv.circle(img,(x,y),20,255,-1)cv.namedWindow(&#x27;1&#x27;)cv.setMouseCallback(&#x27;1&#x27;,draw_circle)while(1): cv.imshow(&#x27;1&#x27;,img) n=cv.waitKey(5) if n==ord(&#x27;q&#x27;): break elif n==ord(&#x27;s&#x27;): cv.imwrite(&#x27;output.jpg&#x27;,img) print(&#x27;保存成功&#x27;)cv.destroyAllWindows() 滑动条事件 1234def createTrackbar(trackbarName, windowName, value, count, onChange):def TrackbarCallback(pos,userdata)def getTrackbarPos(trackbarname, winname):def setTrackbarPos(trackbarname, winname, pos): 123456789101112131415161718192021222324252627import cv2 as cvimport cv2import numpy as npalpha=0.3beta=80img=cv2.imread(&#x27;pic.png&#x27;)img2=cv.imread(&#x27;pic.png&#x27;)def upadateAlpha(x): global alpha,img,img2,beta alpha=cv.getTrackbarPos(&#x27;Alpha&#x27;,&#x27;1&#x27;) alpha=alpha*0.01 img=np.uint8(np.clip((alpha*img2+beta),0,255))def updateBeta(x): global alpha, img, img2,beta beta=cv.getTrackbarPos(&#x27;Beta&#x27;,&#x27;1&#x27;) img=np.uint8(np.clip((alpha*img2+beta),0,255))cv.namedWindow(&#x27;1&#x27;)cv.createTrackbar(&#x27;Alpha&#x27;,&#x27;1&#x27;,0,300,upadateAlpha)cv.createTrackbar(&#x27;Beta&#x27;,&#x27;1&#x27;,0,255,updateBeta)cv.setTrackbarPos(&#x27;Alpha&#x27;,&#x27;1&#x27;,100)cv.setTrackbarPos(&#x27;Beta&#x27;,&#x27;1&#x27;,10)while(1): cv2.imshow(&#x27;1&#x27;,img) if cv.waitKey(1)==ord(&#x27;q&#x27;): breakcv.destroyAllWindows()","categories":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.helicunzai.cn/categories/OpenCV/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.helicunzai.cn/tags/OpenCV/"}]},{"title":"OpenCV:简单实现人脸识别","slug":"OpenCV-Python","date":"2022-09-06T13:17:07.000Z","updated":"2022-10-30T14:19:18.648Z","comments":true,"path":"2022/09/06/OpenCV-Python/","link":"","permalink":"http://www.helicunzai.cn/2022/09/06/OpenCV-Python/","excerpt":"","text":"安装 123pip install numpypip install opencv-pythonpip install opencv-contrib-python OpenCV主要模块 core 核心功能模块。该模块主要包含 OpenCV库的基础结构以及基本操作，例如OpenCV基础数据结构、绘图函数、数组操作相关函数、动态数据结构等calib3d： 这个模块名称是有 calibration（校准）和 3D 两个术语的缩写组合而成。包含了相机标定与立体视觉等功能，例如物体位姿估计、三维重建、摄像头标定等 dnn 深度学习模块。该模块是 OpenCV4版的一个特色，主要包括：构建神经网络、加载序列化网络模型等。但这一模块目前仅适用与正向传递计算（测试网络），原则上不支持反向计算（训练网络）。 feature2d 该模块是由 feature（特征）和 2D 两个术语的缩写组合而成的，其功能主要为处理图像特征点，例如特征检测、描述、匹配等 flann 快速近似最邻近库（Fast Library for Approximate Nearest Neighbors）。该模块是高维的近似近邻快速搜索算法库，主要包含快速近似近邻搜索、聚类等 gapi 该模块是 OpenCV4.0 中新增模块，旨在加速常规的图像处理。与其他模块相比，这个模块主要充当框架，而不是某些特定的计算机视觉算法 highgui 高层 GUI，包含创建和操作显示图像的窗口、处理鼠标事件及键盘命令、提高图形交互可视化界面等 imgcodecs 图像文件读取与保存模块，主要用于图像文件读取与保存 imgproc 该模块名称是由 image（图像）和 process（处理）两个组合而成。是重要的图像处理模块，主要包含：图像滤波、几何变换、直方图、特征检测、目标检测等 ml 机器学习模块，主要包括：统计分类、回归、数据聚类等 objdetect 目标检测模块，主要用于图像的目标检测，如检测 Haar 特征 photo 计算摄像模块，只要包含图像修复、去燥等 stitching 图像拼接模块，主要包含：特征点寻找与匹配图像、估计旋转、自动校准、接缝估计等图像拼接过程的相关内容 video 视频分析模块，主要包含：运动估计、背景分离、对象跟踪等视频处理等 videoio 视频输入/输出模块，主要用于读取、写入视频 或者图像序列 图片基本操作 摄像头采集图片 12345678910# 引入OpenCV库import cv2# 调用摄像头进行拍照 VideoCapture(0)0为默认摄像头cap = cv2.VideoCapture(0)# 获取一帧图片# 如果捕获成功，代码中ret值为真，img为捕获的图像。ret, img = cap.read()# 释放捕获对象cap.release() 读取图片 1cv2.imread(path, 标记) 第二个参数指定图片被读取的方式： cv2.IMREAD_COLOR : 读入彩色图像，默认模式； cv2.IMREAD_GRAYSCALE : 以灰度模式读入图像； cv2.IMREAD_UNCHANGED : 加载图像包含alpha通道。 使用数字简约表示以上三种标记，分别为 1， 0或-1。 123import cv2image_path = &quot;images.jpg&quot;img = cv2.imread(image_path,0) 显示图像 1234567891011import cv2cap=cv2.VideoCapture(0)ret,img=cap.read() ## 如果捕获成功，代码中ret值为真，img为捕获的图像。cap.release()if ret: cv2.imshow(&#x27;demo&#x27;,img) cv2.waitKey(0) cv2.destroyAllWindows()else: print(&quot;错误&quot;) 1imshow(窗口名称, 图片对象) 保存图片 1234567891011import cv2cap=cv2.VideoCapture(0)ret,img=cap.read()cap.release()if ret: cv2.imshow(&#x27;demo&#x27;,img) cv2.imwrite(&#x27;2.png&#x27;, img) cv2.waitKey(0) cv2.destroyAllWindows()else: print(&quot;错误&quot;) 1234567891011import cv2cap=cv2.VideoCapture(0)ret,img=cap.read()cap.release()if ret: cv2.imshow(&#x27;demo&#x27;,img) cv2.imwrite(&#x27;2.png&#x27;, img) cv2.waitKey(0) cv2.destroyAllWindows()else: print(&quot;错误&quot;) 1cv2.imwrite(path, 图片对象) 色彩空间 色彩空间（Color space）是对色彩的组织方式，是坐标系统和子空间的阐述，位于系统的每种颜色都有单个点表示。 RGB OpenCV中默认的色彩空间是BGR。BGR与RGB的区别只是三个颜色信道的位置发生了变化，实际上原理相同。 HSV与HSL色彩空间 为了更好的数字化处理颜色，提出了HSV，HSL两个色彩空间。 HSV色彩空间中，H是色调(hue)，S是饱和度(saturation)， V是明度(value)。 HSL色彩空间中，H是色调(hue)，S是饱和度(saturation)，L是亮度(lightness)。 灰度空间 在OpenCV的灰度空间中，和一般的色彩空间相同，每一个颜色都有三个量，但是只有第一个亮度有值，所以表示为（亮度，0，0）。 其中，亮度是根据如下灰度公式计算而得：Gray = R*0.299 + G*0.587 + B*0.114 色彩空间转换 经常用到的是以下两种： BGR空间到Gray空间 的转换； BGR空间到HSV空间 的转换。 使用的函数为：cv2.cvtColor()。 它的函数声明为： cv2.cvtColor(图片对象，转换类型) 对于BGR到Gray的转换，使cv2.COLOR_BGR2GRAY类型。 同样的，对于BGR到HSV的转换，使用cv2.COLOR_BGR2HSV类型。 1234567891011import cv2, requestsr=requests.get(&#x27;https://raw.githubusercontent.com/MrHarsh10/ImageHosting-/main/img/202209062216524.jpg&#x27;)with open(&#x27;pic.jpg&#x27;,&#x27;wb&#x27;) as f: f.write(r.content)img=cv2.imread(&#x27;pic.jpg&#x27;,1)img2=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)cv2.imshow(&#x27;处理前&#x27;,img)cv2.imshow(&#x27;处理后&#x27;,img2)cv2.waitKey(0)cv2.destroyAllWindows()cv2.imwrite(&#x27;test.jpg&#x27;,img2) 人脸识别应用 类Harr特征 图像中的特征通常是指，图片的像素点经过一系列的运算之后得到的结果，这些结果可能是向量、矩阵和多维数据等等。类Harr特征是一种反映图像的灰度变化的，像素分模块求差值的一种特征。 Harr特征类别 可分为三类：边缘特征、线性特征、中心特征和对角线特征 边缘特征 线性特征 中心特征和对角线特征 使用Harr分类器检测人脸 OpenCV 中的人脸训练模型格式为 XML，可以从 https://github.com/opencv/opencv/tree/master/data/haarcascades 。在此我们使用Harrcascade_frontalface_default.xml模型检测人脸。 声明分类器： 1CascadeClassifier(path) 调用分类函数： 1detectMultiScale(img,scaleFactor, minNeighbors, minSize)` 参数说明： 图片对象：待识别图片对象； scaleFactor：图像缩放比例； minNeighbors：对特征检测点周边多少有效点同时检测，这样可避免因选取的特征检测点太小而导致遗漏； minSize：特征检测点的最小尺寸，可选参数。 12345678910111213import cv2img=cv2.imread(&#x27;1.png&#x27;,1)grayimg=cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)face_cascade = cv2.CascadeClassifier(&#x27;haarcascade_frontalface_default.xml&#x27;)faces = face_cascade.detectMultiScale(grayimg, 1.2, 5)for (x,y,w,h) in faces: print((x,y,w,h)) cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 6)cv2.imshow(&#x27;demo&#x27;,img)cv2.imwrite(&#x27;out.jpg&#x27;,img)cv2.waitKey(0)cv2.destroyAllWindows() 摄像头实时识别 12345678910111213141516import cv2import numpy as npcapture = cv2.VideoCapture(0)if capture.isOpened(): while True: ret, frame = capture.read() grayimg = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) face_cascade = cv2.CascadeClassifier(&#x27;haarcascade_frontalface_default.xml&#x27;) faces = face_cascade.detectMultiScale(grayimg, 1.2, 5) for (x, y, w, h) in faces: cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 0, 255), 2) cv2.imshow(&#x27;frame&#x27;, frame) if cv2.waitKey(1) == ord(&#x27;q&#x27;): capture.release() breakcv2.destroyAllWindows()","categories":[{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.helicunzai.cn/categories/OpenCV/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.helicunzai.cn/tags/OpenCV/"}]},{"title":"计算机网络三级笔记","slug":"计算机网络三级笔记","date":"2022-08-22T10:18:31.000Z","updated":"2022-08-31T15:20:29.787Z","comments":true,"path":"2022/08/22/计算机网络三级笔记/","link":"","permalink":"http://www.helicunzai.cn/2022/08/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89%E7%BA%A7%E7%AC%94%E8%AE%B0/","excerpt":"","text":"第一章 网络系统结构与设计的基本原则 以太网速率分类 传统以太网：10Mbit/s 快速以太网：100Mbit/s 吉比特以太网：10Gbits CSMA/CD 与 CSMA/CA CSMA/CD（Carrier Sense Multiple Access/Collision Detection，带有冲突检测的载波侦听多路存取）。是子网内部所采用的介质访问控制方法。 CSMA/CA(Carrier Sense Multiple Access with Collision Avoidance，带有冲突检测的载波监听的多路访问)。利用 ACK 信号来避免冲突的发生。 光纤分布式数据接口(FDDI)与弹性分组环(RPR) 都是双环结构 宽带城域网 宽带城域网结构 宽带城域网网络平台各层功能 核心交换层（核心层） 主要承担高速数据交换的功能 实现与主干网络的互联，提供城市宽带 IP 数据出口。 提供宽带城域网用户访问 Internet 所需要的路由服务。 将多个汇聚层连接起来，为汇聚层的网络提供高速分组转发，为整个城域网提供一个高速、安全并具有QoS 保障能力的数据传输环境。 边缘汇聚层（汇聚层） 主要承担路由与流量汇聚的功能 根据处理结果把用户流量转发到核心交换层或在本地进行路由处理。 汇接接入层的用户流量，进行数据分组传输的汇聚、转发与交换。 根据接入层的用户流量，进行本地路由、过滤、流量均衡、QoS 优先级管理，以及安全控制、IP 地址转换、流量整形等处理。 用户接入层（接入层） 主要承担用户接入与本地流量控制的功能。 解决“最后一公里”问题。通过各种接入技术，连接最终用户，为它覆盖范围内的用户提供访问 Internet以及其他信息服务。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.helicunzai.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网路","slug":"计算机网路","permalink":"http://www.helicunzai.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/"}]},{"title":"Python爬虫：爬取豆瓣电影榜Top250","slug":"Python爬虫：爬取豆瓣电影榜Top250","date":"2022-08-16T15:57:27.000Z","updated":"2022-08-16T17:16:23.767Z","comments":true,"path":"2022/08/16/Python爬虫：爬取豆瓣电影榜Top250/","link":"","permalink":"http://www.helicunzai.cn/2022/08/16/Python%E7%88%AC%E8%99%AB%EF%BC%9A%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E6%A6%9CTop250/","excerpt":"","text":"前言 现在很多网站都做了反爬，导致单一使用requests库无法爬到东西，经过全网实验，我发现豆瓣的电影排行榜很容易爬取下来的 实现过程 我们使用浏览器检查工具 分析每一项的HTML代码 1234567891011121314151617181920212223242526272829303132333435363738&lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;pic&quot;&gt; &lt;em class=&quot;&quot;&gt;1&lt;/em&gt; &lt;a href=&quot;https://movie.douban.com/subject/1292052/&quot;&gt; &lt;img width=&quot;100&quot; alt=&quot;肖申克的救赎&quot; src=&quot;https://img2.doubanio.com/view/photo/s_ratio_poster/public/p480747492.jpg&quot; class=&quot;&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;info&quot;&gt; &lt;div class=&quot;hd&quot;&gt; &lt;a href=&quot;https://movie.douban.com/subject/1292052/&quot; class=&quot;&quot;&gt; &lt;span class=&quot;title&quot;&gt;肖申克的救赎&lt;/span&gt; &lt;span class=&quot;title&quot;&gt; / The Shawshank Redemption&lt;/span&gt; &lt;span class=&quot;other&quot;&gt; / 月黑高飞(港) / 刺激1995(台)&lt;/span&gt; &lt;/a&gt; &lt;span class=&quot;playable&quot;&gt;[可播放]&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;p class=&quot;&quot;&gt; 导演: 弗兰克·德拉邦特 Frank Darabont 主演: 蒂姆·罗宾斯 Tim Robbins /...&lt;br&gt; 1994 / 美国 / 犯罪 剧情 &lt;/p&gt; &lt;div class=&quot;star&quot;&gt; &lt;span class=&quot;rating5-t&quot;&gt;&lt;/span&gt; &lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;9.7&lt;/span&gt; &lt;span property=&quot;v:best&quot; content=&quot;10.0&quot;&gt;&lt;/span&gt; &lt;span&gt;2674333人评价&lt;/span&gt; &lt;/div&gt; &lt;p class=&quot;quote&quot;&gt; &lt;span class=&quot;inq&quot;&gt;希望让人自由。&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 每个代码都有如上规律，所以我们用正则表达式去匹配每个电影，获取需要的数据 这个需要有正则表达式知识 123pattern=re.compile( &#x27;&lt;div class=&quot;item&quot;&gt;.*?&lt;em class=&quot;&quot;&gt;(.*?)&lt;/em&gt;.*?&lt;span class=&quot;title&quot;&gt;(.*?)&lt;/span&gt;.*?&lt;br&gt;(.*?) / .*? / (.*?)&lt;/p&gt;.*?property=&quot;v:average&quot;&gt;(.*?)&lt;/span&gt;&#x27;,re.S) items=re.findall(pattern,html) 然后网站是以GET方式25为增量换页的 12https://movie.douban.com/top250?start=0&amp;filter=https://movie.douban.com/top250?start=25&amp;filter= 有了以上思路就可以完成爬虫了 代码 123456789101112131415161718192021222324252627282930313233343536373839import requests,re,csvdef getpage(url): headers=&#123; &#x27;User-Agent&#x27;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36 Edg/104.0.1293.54&quot; &#125; response=requests.get(url,headers=headers) if response.status_code==200: return response.text print(&quot;爬取失败&quot;) return Nonedef parsehtml(html): pattern=re.compile( &#x27;&lt;div class=&quot;item&quot;&gt;.*?&lt;em class=&quot;&quot;&gt;(.*?)&lt;/em&gt;.*?&lt;span class=&quot;title&quot;&gt;(.*?)&lt;/span&gt;.*?&lt;br&gt;(.*?) / .*? / (.*?)&lt;/p&gt;.*?property=&quot;v:average&quot;&gt;(.*?)&lt;/span&gt;&#x27;,re.S) items=re.findall(pattern,html) return items;def write(items): with open(&quot;豆瓣电影Top250.csv&quot;,mode=&quot;w&quot;, encoding=&quot;utf-8-sig&quot;, newline=&quot;&quot;) as f: writer = csv.writer(f) headerList=[&#x27;排名&#x27;,&#x27;电影名&#x27;,&#x27;上映时间&#x27;,&#x27;分类&#x27;,&#x27;豆瓣评分&#x27;] writer.writerow(headerList) for i in items: tmp=[] tmp.append(i[0]) tmp.append(i[1]) tmp.append(str(i[2]).strip()) tmp.append(str(i[3]).strip()) tmp.append(str(i[4]).strip()) print(tmp[0],tmp[1],tmp[2],tmp[3],tmp[4]) writer.writerow(tmp)def main(): items=[] for i in range(0,250,25): url=&#x27;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#x27;.format(i) text=getpage(url) items+=parsehtml(text) write(items)main() 结果 非常基础的爬虫入门例子","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Qt工具类","slug":"Qt工具类","date":"2022-08-14T02:34:48.000Z","updated":"2022-08-15T09:19:44.404Z","comments":true,"path":"2022/08/14/Qt工具类/","link":"","permalink":"http://www.helicunzai.cn/2022/08/14/Qt%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"字符串类 操作字符串 “+” QString::append() QString::sprintf() 12QString str;str.sprintf(&quot; %s &quot;,&quot;hi&quot;); QString::arg() 12QString str;str=QString(&quot;%1 a %2&quot;).arg(&quot;1&quot;).arg(&quot;2&quot;); 组合字符串 insert() 插入字符串 prepend() 开头插入 replace() 替代 QString::trimmed() 移除两端的空白字符 QString::simplified() 移除两端的空白字符,使用单个空格字符代替空白字符 查询字符串 QString::startsWith() 12QString str=&quot;sddsa&quot;str.startsWith(&quot;s&quot;,Qt::CaseSensitive);// true QString::endsWith() 结尾 QString::contains() 包含 操作符 &gt;=&lt; 字符串转换 toInt() toAscii toLatin1() toUtf8() toLocal8Bit() 12345QString str=&quot;welcome to you&quot;;QByteArray b=str.toAscii();qDebug&lt;&lt;b;b.append(&quot;hello world&quot;);qDebug()&lt;&lt;ba.data(); 容器类 QList类 QList::append() QList::prepend() QList::insert() 123QList&lt;QString&gt;list;QString str(&quot;sdsd&quot;);list&lt;&lt;str; QLinkedList类 QLinkedList是一个链式列表，以非连续的内存块保存 QVector类 相邻的内存储存给定数据类型的一组数值 Java风格迭代器遍历容器 *两种不同类型的Java风格迭代器数据类型* 容器类 只读迭代器类 读写迭代器类 QList,QQueue QListIterator QMutableListIterator QLinkedList QLinkedListIterator QMutableLinkedListIterator QVector,QStack QVectorIterator QMutableVectorIterator 123456789101112#include &lt;QCoreApplication&gt;#include &lt;QDebug&gt;int main(int argc,char *argv[])&#123; QCoreApplication a(argc,argv); QList&lt;int&gt;list; list&lt;&lt;1&lt;&lt;2&lt;&lt;3&lt;&lt;4&lt;&lt;5; QListIterator&lt;int&gt;i(list); for(;i.hasNext();) qDebug()&lt;&lt;i.next; return a.exec;&#125; QListIterator QListIterator::toBack() QListIterator::hasPrevious() QListIterator::previous() QListIterator::toFront() QListIterator::peeknext() QListIterator::peekPrevious() QListIterator::findNext() QListIterator::findPrevious() STL风格迭代器遍历容器 STL风格迭代器数据类型* 容器类 只读迭代器类 读写迭代器类 QList QListIterator::const_iterator QListIterator::iterator QLinkedList QLinkedListIterator::const_iterator QLinkedListIterator::iterator QVector,QStack QVectorIterator::const_iterator QVector::iterator","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.helicunzai.cn/categories/Qt/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.helicunzai.cn/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://www.helicunzai.cn/tags/Qt/"}]},{"title":"requests库的使用","slug":"requests的使用","date":"2022-08-13T10:22:05.000Z","updated":"2022-08-13T13:31:39.393Z","comments":true,"path":"2022/08/13/requests的使用/","link":"","permalink":"http://www.helicunzai.cn/2022/08/13/requests%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"请求 post(‘url’) put(‘url’) delete(‘url’) head(‘url’) options(‘url’) get(‘url’) GET请求 1234567891011import requestsfrom urllib.parse import urlencodedata=&#123; &#x27;name&#x27;:&#x27;hha&#x27;, &#x27;age&#x27;:&#x27;a&#x27;&#125;r=requests.get(&#x27;http://httpbin.org/get&#x27;,params=data)print(r.text)js=r.json()print(js[&quot;headers&quot;][&quot;User-Agent&quot;])r.text) 下载图片 1234import requestsr=requests.get(&#x27;https://s2.loli.net/2022/08/08/XPao6Bwfkjc2drg.jpg&#x27;)with open(&#x27;pic.jpg&#x27;,&#x27;wb&#x27;) as f: f.write(r.content) POST请求 123456import requestsdata=&#123; &quot;1&quot;:&quot;1&quot;&#125;r=requests.post(&#x27;http://httpbin.org/post&#x27;,data=data)print(r.text) 文件上传 123456import requestsfiles=&#123; &#x27;files&#x27;:open(&#x27;pic.jpg&#x27;,&#x27;rb&#x27;)&#125;r=requests.post(&#x27;http://httpbin.org/post&#x27;,files=files)print(r.text) 会话维持 12345import requestss=requests.session()s.get(&#x27;http://httpbin.org/cookies/set/number/12345&#x27;)r=s.get(&#x27;http://httpbin.org/cookies&#x27;)print(r.text)","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"刷题笔记㈠","slug":"刷题笔记㈠","date":"2022-08-11T13:10:25.000Z","updated":"2022-08-11T15:45:00.142Z","comments":true,"path":"2022/08/11/刷题笔记㈠/","link":"","permalink":"http://www.helicunzai.cn/2022/08/11/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%88%A0/","excerpt":"","text":"额，感觉这很奇怪，下次不写了 面试题 08.05. 递归乘法 - 力扣（LeetCode） 思路： AB=MAX(MIN-1+1)=MAX*(MIN-1)+MAX 123456789101112class Solution &#123;public: int multiply(int A, int B) &#123; int Max=max(A,B); int Min=min(A,B); if(Min==0) return 0; else if(Min==1) return Max; return multiply(Min-1,Max)+Max; &#125;&#125;; 2119. 反转两次的数字 - 力扣（LeetCode） 老实人真会反转两次 123456class Solution &#123;public: int isSameAfterReversals(int num) &#123; return num == 0 || num % 10 != 0; &#125;&#125;; 剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode） 越界处理用取模 12345678910class Solution &#123;public: string reverseLeftWords(string s, int n) &#123; int len=s.length(); string str(s); for(int i=0;i&lt;len;i++) s[i]=str[(i+n)%len]; return s; &#125;&#125;; 136. 只出现一次的数字 - 力扣（LeetCode） 本题采用异或运算 异或运算性质 a^a=0； a^0=a; ab=ba 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans=0; for(int i=0;i&lt;nums.size();i++) ans^=nums[i]; return ans; &#125;&#125;; 268. 丢失的数字 - 力扣（LeetCode） 求和做减法 12345678910class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(); int sum=n*(n+1)/2; for(auto it:nums) sum-=it; return sum; &#125;&#125;; 剑指 Offer 53 - II. 0～n-1中缺失的数字 - 力扣（LeetCode） 123456789101112class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int ans=0; int n=nums.size()+1; for(int i=0;i&lt;n;i++) ans^=i; for(auto it:nums) ans^=it; return ans; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://www.helicunzai.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.helicunzai.cn/tags/C/"},{"name":"算法","slug":"算法","permalink":"http://www.helicunzai.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C++的STL","slug":"C-的STL","date":"2022-08-10T08:51:16.000Z","updated":"2022-08-11T09:56:39.691Z","comments":true,"path":"2022/08/10/C-的STL/","link":"","permalink":"http://www.helicunzai.cn/2022/08/10/C-%E7%9A%84STL/","excerpt":"","text":"开始 STL的代码从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），几乎所有的代码都采用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说。 用STL我们就不用反复实现一些代码，提高开发效率。当然这个需要数据结构基础 vector动态数组 头文件 1#include &lt;vector&gt; 初始化 123456789101112vector&lt;int&gt; ans;//int的型的数组vector&lt;structure&gt; ans;//一个structure结构体的数组//指定长度的初始化vector&lt;short&gt; ans(n);vector&lt;double&gt; ans(n,2);//长度为n,全为2的数组vector&lt;double&gt; shaow(ans);//拷贝初始化，类型长度需相同vector&lt;int&gt; a&#123;1, 2, 3, 4, 5&#125;;//二维vector&lt;int&gt;ans[5];//行为固定的5，列为动态可变vector&lt;vectot&lt;int&gt; &gt;num;//行列均可以变vector&lt;vector&lt;int&gt; &gt; a(n + 1, vector&lt;int&gt;(m + 1, 0));//固定n+1行m+1列初始值为0的二维数组 访问遍历 123456789101112131415#include &lt;iostream&gt;#include &quot;vector&quot;using namespace std;int main() &#123; int n = 5; vector&lt;int&gt; num(5, 1); cout&lt;&lt;num[2];//访问下标为2的元素//智能指针遍历 for (auto i: num) cout &lt;&lt; i &lt;&lt; &quot; &quot;;//遍历 for(int i=0;i&lt;num.size();i++) cout&lt;&lt;num[i]&lt;&lt;&#x27; &#x27;; return 0;&#125; 方法函数 函数 含义 a.empty() 判断是否为空，空为真 a.begin() 返回首元素的迭代器 a.end() 返回末位元素的迭代器 a.size() 返回数据个数 a.insert(it,x) 先任意迭代器插入一个元素 a.push_back() 尾部添加一个 a.pop_back() 删除最后一个元素 a.front() 返回第一个数据 a.clear() 清除元素 a.resize(n,v) 改变数组大小为n,赋值为v a.erase(f,l) 删除[f,i)的所有元素 sort(a.begin(),a.end()) 排序 代码 12345678910#include &lt;iostream&gt;#include &quot;vector&quot;using namespace std;int main() &#123; int n = 5; vector&lt;int&gt; num(5, 1); for(vector&lt;int&gt;::iterator it=num.begin();it!=num.end();it++) cout&lt;&lt;*it&lt;&lt;&#x27; &#x27;; return 0;&#125; stack栈 头文件 1#include &lt;stack&gt; 初始化 1stack&lt;int&gt;ans; 方法函数 函数 含义 push() 压栈 pop() 出栈 empty() 空为真 top() 取得栈顶元素 size() 元素个数 代码 1234567891011121314#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; stack&lt;int&gt;a; int i; while(!a.empty()) &#123; i=a.top(); cout&lt;&lt;i&lt;&lt;&quot; &quot;; a.pop(); &#125; return 0;&#125; queue队列 头文件 1#include&lt;queue&gt; 初始化 1queue&lt;int&gt;ans; 方法函数 函数 含义 front() 返回队首 back() 返回队尾元素 pop() 出队 push() 进队 size() 元素个数 empty() 空队为空 代码 12345678910111213141516#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123; queue&lt;int&gt;a; for(int i=0;i&lt;10;i++) a.push(i); int i; while(!a.empty()) &#123; i=a.front(); cout&lt;&lt;i&lt;&lt;&#x27; &#x27;; a.pop(); &#125; return 0;&#125; deque双队列 头文件 1#include &lt;deque&gt; 初始化 1deque&lt;int&gt;ans; 方法函数 函数 含义 push_back()push_front() 入队 back()front() 访问 pop_back()pop_back() 出队 erase(iterator f,iterator l) 删除 empty() 空为真 size() 元素数量 clear() 清空 sort(iterator f,iterator l) 排序 代码 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;deque&gt;#include &quot;algorithm&quot;using namespace std;int main() &#123;deque&lt;int&gt;a;int b[5]=&#123;3,8,9,6,2&#125;;for(int i=0;i&lt;5;i++) a.push_front(b[i]);sort(a.begin(),a.end());int i;while(!a.empty())&#123; i=a.back(); cout&lt;&lt;i&lt;&lt;&#x27; &#x27;; a.pop_back();&#125; return 0;&#125; priority_queue优先队列 头文件 1#include&lt;queue&gt; 头文件 12#include &lt;map&gt;priority_queue&lt;Type, Container, Functional&gt; 方法函数 函数 含义 top() 队首元素 push() 入队 pop() 出队 empty() 空为真 size() 元素个数 代码 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main()&#123; priority_queue&lt;int&gt; a; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; c; //这样就是小顶堆 for (int i = 0; i &lt; 5; i++) &#123; a.push(i); c.push(i); &#125; while (!a.empty()) &#123; cout &lt;&lt; a.top() &lt;&lt; &#x27; &#x27;; a.pop(); &#125; cout &lt;&lt; endl; while (!c.empty()) &#123; cout &lt;&lt; c.top() &lt;&lt; &#x27; &#x27;; c.pop(); &#125; cout &lt;&lt; endl; return 0;&#125; map映射 头文件 1#include&lt;map&gt; 初始化 map&lt;string,int&gt;a; 函数方法 函数 含义 find(key) 返回键为key的映射的迭代器当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end() erase(it) 删除迭代器对应的键和值 erase(key) 根据映射的键删除键和值 erase(first,last) 删除左闭右开区间迭代器对应的键和值 size() 返回对数 clear() 清空所有元素 insert() 插入元素 empty() 是否为空 begin() 第一个元素的迭代器 end() 返回尾部的迭代器（最后一个元素的下一个地址） rbegin() 返回最后一个元素的迭代器（地址） rend() 返回第一个元素的迭代器 rend() 返回第一个元素的迭代器 count(key) 查看元素是否存在 lower_bound() 返回指向键值&gt;= key的第一个元素 upper_bound() 返回指向键值&gt; key的第一个元素的迭代器， 代码 1234567891011121314151617#include&lt;iostream&gt;#include &lt;map&gt;using namespace std;int main()&#123;map&lt;int,string&gt;a;a[1]=&quot;hello&quot;;a[2]=&quot;hi&quot;;cout&lt;&lt;a[1];cout&lt;&lt;endl; map&lt;int,string&gt;::iterator it; for(it=a.begin();it!=a.end();it++) cout&lt;&lt;it-&gt;first&lt;&lt;&#x27;:&#x27;&lt;&lt;it-&gt;second&lt;&lt;endl; for(auto i:a) cout&lt;&lt;i.first&lt;&lt;&quot;:&quot;&lt;&lt;i.second&lt;&lt;endl; return 0;&#125; set集合 集合不重合且有序 头文件 1#include &lt;set&gt; 方法函数 函数 含义 begin() 返回第一个元素的迭代器 end() 返回最后一个元素的迭代器 rbegin() 返回逆序迭代器 rend() 返回逆序迭代器 clear() 删除set容器中的所有的元素 empty() 判断是否为空 insert() 插入一个元素 size() 容器中的元素个数 erase(iterator)erase(first,second） 删除指向的值 erase(key_value) 删除键值key_value的值 find(元素) 查找set中的某一元素，返回迭代器 lower_bound(k) 返回大于等于k的第一个元素的迭代器 upper_bound(k) 返回大于k的第一个元素的迭代器 代码 123456789101112131415161718#include&lt;iostream&gt;#include &lt;set&gt;using namespace std;int main()&#123; set&lt;int&gt;a; a.insert(8); a.insert(3); a.insert(9); a.insert(7); a.insert(6); a.insert(5); for(set&lt;int&gt;::iterator it=a.begin();it!=a.end();it++) cout&lt;&lt;*it&lt;&lt;&quot; &quot;; return 0;&#125;//结果为3 5 6 7 8 9 pair对组 pair只含有两个元素，可以看作是只有两个元素的结构体. 头文件 1#include&lt;utility&gt; 字符串 头文件 1#include &lt;string&gt; 初始化 12345678string str1; //生成空字符串string str2(&quot;123456789&quot;); //生成&quot;1234456789&quot;的复制品 string str3(&quot;12345&quot;, 0, 3);//结果为&quot;123&quot; ，从0位置开始，长度为3string str4(&quot;123456&quot;, 5); //结果为&quot;12345&quot; ，长度为5string str5(5, &#x27;2&#x27;); //结果为&quot;22222&quot; ,构造5个字符&#x27;2&#x27;连接而成的字符串string str6(str2, 2); //结果为&quot;3456789&quot;，截取第三个元素（2对应第三位）到最后 函数方法 函数 含义 sort(s.begin(),s.end()); 排序 size()length() 长度 max_size() 返回string对象最多包含的字符数 capacity() 重新分配内存之前，string对象能包含的最大字符数 push_back() 末尾插入 insert(pos,element) 插入 append(str) 末尾添加字符串 erase(it)erase(iterator p) 删除指定字符 erase(iterator first, iterator last) 删除字符串中迭代器区间所有字符 clear() 清空 replace(pos,n,str) 把当前字符串从索引pos开始的n个字符替换为str replace(pos,n,x,c) 把当前字符串从索引pos开始的n个字符替换为x个字符c replace(it1,it2,str) 把当前字符串[it1,it2)区间替换为str tolower() 转换为小写 toupper() 转换为大写 substr(pos,n) 截取从pos索引开始的n个字符 find (str, pos)find (c, pos) 在当前字符串的pos索引位置(默认为0)开始，查找子串str，返回找到的位置索引，-1表示查找不到子串 rfind (str, pos) 在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引 find_first_of (str, pos) 在当前字符串的pos索引位置(默认为0)开始，查找子串s的字符 .find_first_not_of (str,pos) 在当前字符串的pos索引位置(默认为0)开始，查找第一个不位于子串s的字符 find_last_of(str, pos) 当前字符串的pos索引位置开始，查找最后一个位于子串s的字符 find_last_not_of ( str, pos) 在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符 bitsei位组 头文件 1#include &lt;bitset&gt; 初始化 1234bitset &lt; n &gt;a; //a有n位，每位都为0bitset &lt; n &gt;a(b);bitset &lt; n &gt;a(s,pos,n);//a是s中从位置pos开始的n个位的副本bitset &lt; n &gt;a(s); 函数方法 函数 含义 any() 是否存在置为1的二进制位，有返回true none() b中是否没有1 count() 1的个数 size() 二进制位的个数 test(pos) 在pos位置是否为1，是返回true b.set() 所有位都置为1 reset() 所有位都置为0 reset(pos) pos位置置为0 flip() 所有二进制位取反 flip(pos) pos位置取反 to_ulong() 同样的二进制位返回一个unsigned long值 bitset也支持位运算 array数组 头文件 1#include &lt;array&gt; 初始化 1234array&lt;int, 100&gt; a;//声明一个大小为100的int型数组array&lt;int, 100&gt; a&#123;&#125;;//声明一个大小为100的int型数组，初始值均为0array&lt;int, 100&gt; a&#123;1, 2, 3&#125;;//始化部分值，其余全部为0array&lt;int, 100&gt; a = &#123;1, 2, 3&#125;; 访问遍历 12345678910111213array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;for(int i = 0; i &lt; 4; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; \\n&quot;[i == 3];//迭代器for(auto i : a) cout &lt;&lt; i &lt;&lt; &quot; &quot;;//at访问array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;int res = a.at(1) + a.at(2);cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;;get&lt;1&gt;(a) = x;//将a数组下标为1位置处的值改为x 方法函数 函数 含义 begin() 第一个元素的访问迭代器 end() 返回容器最后一个元素之后一个位置的访问迭代器 rbegin() 返回最后一个元素的访问迭代器 rend() 返回第一个元素之前一个位置的访问迭代器 size() 返回容器中元素的数量 max_size() 返回容器可容纳元素的最大数量 empty() 判断容器是否为空 at(n) 返回容器中 n 位置处元素的引用 front() 返回容器中第一个元素的直接引用 back() 返回容器中最后一个元素的直接引用 data() 返回一个指向容器首个元素的指针 fill(x) 将 x 这个值赋值给容器中的每个元素,相当于初始化 array1.swap(array2) 交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型 sort() 排序 tuple元组 头文件 1#include &lt;tuple&gt; 初始化 1234567tuple&lt;int, int, string&gt; t1;//声明一个空的tuple三元组t1 = make_tuple(1, 1, &quot;hahaha&quot;);tuple&lt;int, int, int, int&gt; t2(1, 2, 3, 4);auto p = make_pair(&quot;wang&quot;, 1);tuple&lt;string, int&gt; t3 &#123;p&#125;; //将pair对象赋给tuple对象 操作 读取修改 12int first = get&lt;0&gt;(t);get&lt;0&gt;(t) = 1; 获取元素个数 12tuple&lt;int, int, int&gt; t(1, 2, 3);cout &lt;&lt; tuple_size&lt;decltype(t)&gt;::value &lt;&lt; &quot;\\n&quot;; // 3 解包 12345int one, three;string two; tuple&lt;int, string, int&gt; t(1, &quot;hahaha&quot;, 3);tie(one, two, three) = t;cout &lt;&lt; one &lt;&lt; two &lt;&lt; three &lt;&lt; &quot;\\n&quot;; // 1hahaha3","categories":[{"name":"C++","slug":"C","permalink":"http://www.helicunzai.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.helicunzai.cn/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://www.helicunzai.cn/tags/STL/"}]},{"title":"C++编程基础","slug":"C-编程","date":"2022-08-10T03:28:35.000Z","updated":"2022-09-07T15:26:55.620Z","comments":true,"path":"2022/08/10/C-编程/","link":"","permalink":"http://www.helicunzai.cn/2022/08/10/C-%E7%BC%96%E7%A8%8B/","excerpt":"","text":"从C到C++ C是面向过程的语言，对于小规模程序还是得心应手的，为了程序设计的更见简易，C++最为C语言的自增版，保留原来语法，增加面向对象机制。 万能头文件 1#include&lt;bits/stdc++.h&gt;//万能头文件 几乎包含所有的头文件 最简单的C++程序 123456#include &lt;iostream&gt;int main() &#123; std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl; return 0;&#125; C++规定main函数必须声明为int型。 cout为输出流对象 输入输出 123456789#include &lt;iostream&gt;int main()&#123; int a,b,sum; cin&gt;&gt;a&gt;&gt;b; sum = a + b; cout&lt;&lt;″a + b =″&lt;&lt;sum&lt;&lt;endl; return 0; &#125; 内联函数 内联函数是直接复制“镶嵌”到主函数中去的，就是将内联函数的代码直接放在内联函数的位置上 当数本身内容比较少，代码比较短，函数功能相对简单，函数被调用得频繁，我们用内联函数 123inline void function( int a )&#123;&#125; 函数模板 12345template &lt;class T&gt;//T代表一个待定的类型，会改变为传入的参数的类型返回值类型 函数名(参数列表)&#123;函数体&#125; 引用和引用形参 1int &amp;b = a; //声明b是a的引用（别名） 参数传递 1void sum(int a,int b=1)&#123; &#125;//正确 默认参数必须写在一般参数的后面 一元作用域运算符:: 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int n=55;int main()&#123; int n=5; cout&lt;&lt;::n&lt;&lt;&#x27;\\n&#x27;; return 0; &#125;","categories":[{"name":"C++","slug":"C","permalink":"http://www.helicunzai.cn/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.helicunzai.cn/tags/C/"},{"name":"OP编程","slug":"OP编程","permalink":"http://www.helicunzai.cn/tags/OP%E7%BC%96%E7%A8%8B/"}]},{"title":"urllib库的使用","slug":"urllib库的使用","date":"2022-08-09T06:51:35.000Z","updated":"2022-08-13T10:11:19.764Z","comments":true,"path":"2022/08/09/urllib库的使用/","link":"","permalink":"http://www.helicunzai.cn/2022/08/09/urllib%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"开始 urllib是Python内置的HTTP请求模块，其包含以下四个模块 request:HTTP请求模块 error:异常处理模块 parse:工具模块，拆分、解析、合并 robotparser:识别网站robots.txt文件，判断哪些网站可以爬。 请求发送 urlopen() 123456import urllib.requestresponse=urllib.request.urlopen(&#x27;https://www.baidu.com&#x27;)print(response.read().decode(&#x27;utf-8&#x27;))#read可以返回网页内容， 网页编码为UTF-8需要用decode,不然会有转义字符print(type(response)) #类型print(response.status) #获取响应状态码print(response.getheaders()) #获取响应头rs()) data参数 data参数为可选，使用需要，使用bytes()转换为字节流编码格式 12345import urllib.requestimport urllib.parsedata=bytes(urllib.parse.urlencode(&#123;&#x27;B&#x27;:&#x27;1&#x27;&#125;),encoding=&#x27;utf-8&#x27;)response=urllib.request.urlopen(&#x27;http://httpbin.org/post&#x27;,data=data)print(response.read().decode(&#x27;utf8&#x27;)) 我们的数据出现在了form字段里，这是我们用POST方法传递的数据 timeout参数 12345678import urllib.requestimport sockettry: response=urllib.request.urlopen(&#x27;http://www.google.com&#x27;,timeout=1) print(response.read().decode(&#x27;utf-8&#x27;))except urllib.error.URLError as e: if isinstance(e.reason,socket.timeout): print(&#x27;TIME OUT&#x27;) Request() urllib.request — Extensible library for opening URLs — Python 3.10.6 documentation Request能实现更多参数的请求 123def __init__(self, url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None): URL:请求URL data:必须为bytes(),如果是字典可以用urllib.parse.urlencode() headers:为一个字典 origin_req_host：表示这个请求是否是无法验证的 method:请求方法 123456789101112131415161718from urllib import request,parseurl=&#x27;http://httpbin.org/post&#x27;headers=&#123; &#x27;Host&#x27;:&#x27;httpbin.org&#x27;, &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36 Edg/104.0.1293.47&#x27;&#125;dict=&#123;&#x27;b&#x27;:1&#125;data=bytes(parse.urlencode(dict),encoding=&#x27;utf8&#x27;)data=bytes(parse.urlencode(&#123;&#x27;B&#x27;:&#x27;1&#x27;&#125;),encoding=&#x27;utf-8&#x27;)req=request.Request(url,data=data,headers=headers,method=&#x27;POST&#x27;)&quot;&quot;&quot;另一种请求头的添加方式req=request.Request(url=url,data=data,method=&#x27;POST&#x27;)req.add_header(&#x27;Host&#x27;,&#x27;httpbin.org&#x27;,)&quot;&quot;&quot;response=request.urlopen(req)print(response.read().deco 进阶用法 Handler 现在我们介绍Handler 比如： HTTPDefaultErrorHandler:用于处理响应错误，错误会抛出HTTPError类型的异常 HTTPRedirectHandler:处理重定向 HTTPCookieProcesser:处理Cookies ProxyHandler:设置代理，默认代理为空 HTTPPasswordMgr:用于管理密码，维护了用户名和密码 HTTPBasicAuthHandler:用于管理认证 Cookies 1234567import http.cookiejar,urllib.requestfilename=&#x27;cookies.txt&#x27;cookie=http.cookiejar.MozillaCookieJar(filename)handler=urllib.request.HTTPCookieProcessor(cookie)opener=urllib.request.build_opener(handler)response=opener.open(&#x27;http://www.baidu.com&#x27;)cookie.save(ignore_discard=True,ignore_expires=True) 1234567import http.cookiejar,urllib.requestcookie=http.cookiejar.CookieJar()handler=urllib.request.HTTPCookieProcessor(cookie)opener=urllib.request.build_opener(handler)response=opener.open(&#x27;http://www.baidu.com&#x27;)for item in cookie: print(item. 1234567import http.cookiejar,urllib.requestcookie=http.cookiejar.LWPCookieJar()cookie.load(&#x27;cookies.txt&#x27;,ignore_expires=1,ignore_discard=1)handler=urllib.request.HTTPCookieProcessor(cookie)opener=urllib.request.build_opener(handler)response=opener.open(&#x27;http://www.baidu.com&#x27;)print(response.read.decode(&#x27;utf-8&#x27;)) 异常处理 URLError 12345from urllib import request,errortry: response=request.urlopen(&#x27;http://mrharsh.top/index.htm&#x27;)except error.URLError as e: print(e.reason) HTTPError 1234567from urllib import request,errortry: response=request.urlopen(&#x27;http://mrharsh.top/index.htm&#x27;)except error.HTTPError as e: print(e.reason) print(e.code) URLError是HTTPError的父类 1234567891011from urllib import request,errortry: response=request.urlopen(&#x27;http://mrharsh.top/index.htm&#x27;)except error.HTTPError as e: print(e.reason) print(e.code)except error.URLError as e: print(e.reason)else: print(&#x27;SUCCESS!!&#x27;) 解析链接 urlparse 123from urllib.parse import urlparseresult=urlparse(&#x27;https://www.baidu.com/s?wd=%E7%89%B9%E6%9C%97%E6%99%AE%E6%88%96%E5%B0%86%E9%9D%A2%E4%B8%B4%E6%9C%80%E9%AB%9830%E5%B9%B4%E5%88%91%E6%9C%9F&amp;tn=baiduhome_pg&amp;usm=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rsv_pq=beff06110014fb0c&amp;oq=%E9%BB%91%E5%B1%B1%E5%8F%91%E7%94%9F%E6%9E%AA%E5%87%BB%E4%BA%8B%E4%BB%B6%E8%87%B411%E6%AD%BB6%E4%BC%A4&amp;rsv_t=203cnvqhWV3frPIJkl4SxrljZIVFGNv6ZJkChXgM4YBU2qiBwG0dd0rTfPGYEJdqPkDg&amp;rqid=beff06110014fb0c&amp;rsf=a7183c00b74706d91bca215ee108b466_1_15_2&amp;rsv_dl=0_right_fyb_pchot_20811&amp;sa=0_right_fyb_pchot_20811&#x27;)print(result) urlunparse() 123from urllib.parse import urlunparsedata=[&#x27;https&#x27;,&#x27;wwww.baidu.com&#x27;,&#x27;index.html&#x27;,&#x27;user&#x27;,&#x27;a=6&#x27;,&#x27;comment&#x27;]print(urlunparse(data)) urlsplit 1234from urllib.parse import urlsplitresult=urlsplit(&#x27;https://www.baidu.com/s?wd=python&amp;pn=10&amp;oq=python&amp;tn=baiduhome_pg&amp;ie=utf-8&amp;usm=4&amp;rsv_idx=2&amp;rsv_pq=cb482fb3002cef17&amp;rsv_t=6415j2DcN1b3Ov7Yj0M6vjanBErrN6Meq3YKeNQ%2BhsGLzD1xnsUAYddpkN%2FlYnFdsQ07&#x27;)for i in result: print(i) urlunsplit() 123from urllib.parse import urlunsplitdata=[&#x27;http&#x27;,&#x27;www.baidu.com&#x27;,&#x27;index.html&#x27;,&#x27;a=0&#x27;,&#x27;c&#x27;]print(urlunsplit(data)) urljoin() 12from urllib.parse import urljoinprint(urljoin(&#x27;http://www.baidu.com&#x27;,&#x27;index.html&#x27;)) urlencode 在GET中加参数 12345678from urllib.parse import urlencodeparams=&#123; &#x27;name&#x27;:&#x27;s&#x27;, &quot;1&quot;:&quot;2&quot;&#125;base_url=&#x27;http//www.baidu.com&#x27;urll=base_url+urlencode(params)print(urll) parse_qs() 反序列化 1234from urllib.parse import urlsplit,parse_qsresult=urlsplit(&#x27;https://www.baidu.com/s?wd=python&amp;pn=10&amp;oq=python&amp;tn=baiduhome_pg&amp;ie=utf-8&amp;usm=4&amp;rsv_idx=2&amp;rsv_pq=cb482fb3002cef17&amp;rsv_t=6415j2DcN1b3Ov7Yj0M6vjanBErrN6Meq3YKeNQ%2BhsGLzD1xnsUAYddpkN%2FlYnFdsQ07&#x27;)print(parse_qs(result.query)) quote() 将内容转为URL编码 1234from urllib.parse import quote,urljoinkeyword=&#x27;python&#x27;url=&#x27;http://www.baidu.com/s?wd=&#x27;+quote(keyword)print(url) unquote() 12345from urllib.parse import quote,urljoin,unquotekeyword=&#x27;你好&#x27;url=&#x27;https://www.baidu.com/s?wd=&#x27;+quote(keyword)print(url)print(unquote(url)) Robots协议 robotparser() set_ur():设置Robots.txt链接 read():读取robots.txt并分析 parse():解析robots.txt文件 can_fetch():传入User-Agent和URL,判读是否可爬取 mtime():返回上次抓取的时间 modified():设置当前时间为上次抓取时间 123456from urllib.robotparser import RobotFileParserrp=RobotFileParser()rp.set_url(&#x27;https://www.bilibili.com/robots.txt&#x27;)rp.read()print(rp.can_fetch(&#x27;Yisouspider&#x27;,&#x27;https://www.bilibili.com/video/BV1fN4y1u7s1?spm_id_from=333.1007.tianma.2-3-6.click&#x27;))print(rp.can_fetch(&#x27;*&#x27;,&#x27;https://www.bilibili.com/video/BV1fN4y1u7s1?spm_id_from=333.1007.tianma.2-3-6.click&#x27;))","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"爬虫基础","slug":"爬虫基础","date":"2022-08-09T02:48:02.000Z","updated":"2022-08-09T05:36:50.356Z","comments":true,"path":"2022/08/09/爬虫基础/","link":"","permalink":"http://www.helicunzai.cn/2022/08/09/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/","excerpt":"","text":"HTTP基本原理 参考资料： HTTP 教程 | 菜鸟教程 (runoob.com) URI和URL URI:统一资源标识符 URL:统一资源定位符 URN:统一资源名称 现在互联网，URN用得很少，一般网页链接🔗称为URL 超文本 网页源代码HTML称为超文本 HTTP和HTTPS HTTP:超文本传输协议 HTTPS:HTTP下加入SSL层 HTTP 请求过程 我们利用浏览器”检查“工具的网络来观察这个过程 General部分 Request URL:请求的URL Request Method:请求方法 Status Code: 响应状态码 Remote Address:远程服务器的地址和端口 Referrer Policy:Referrer判别策略 Response Header:响应头 Request Header:请求头 请求 请求由客户端发出，分为4部分 请求方法:Request Method 请求网址:Request URL 请求头:Request Headers 请求体:Request Body 请求方法 常见的为：GET和POST GET 与POST区别 GET的参数在URL里面，而POST请求的数据以表单传输，包含在请求体 GET的数据只有1024字节，而POST没有限制 其他请求方法 请求的网址 请求的网址即URL 请求头 Accept:请求报头域，指定客户端接收哪些类型的信息 Accept-Language:指定客户端可接受语言类型 Host:指定请求资源的主机IP和端口 Cookie:储存在用户本地终端上的数据,特定的 web文档关联在一起, 保存了该客户机访问这个Web 文档时的信息, 当客户机再次访问这个 Web 文档时这些信息可供该文档使用。 Referer:标识请求是从那个页面发过来的 User-Agent:一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。 Content-Type:内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件 请求体 请求体承载的是POST的表单数据，对于GET，请求为空 响应 响应状态码 常见的 HTTP 状态码： 200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误 其它可以参考HTTP 状态码 | 菜鸟教程 响应头 响应头包含服务器对请求的应答信息，如Content-Type、Sever、Set-Cookie 响应体 响应体包含响应的正文数据 网页基础 网页组成 网页是由HTML、CSS、JavaScript组成 如果想学爬虫，必须要点Web基础","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/tags/%E7%88%AC%E8%99%AB/"}]}],"categories":[{"name":"微机原理与接口技术","slug":"微机原理与接口技术","permalink":"http://www.helicunzai.cn/categories/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/"},{"name":"STM32","slug":"STM32","permalink":"http://www.helicunzai.cn/categories/STM32/"},{"name":"ES6","slug":"ES6","permalink":"http://www.helicunzai.cn/categories/ES6/"},{"name":"前端","slug":"前端","permalink":"http://www.helicunzai.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://www.helicunzai.cn/categories/Vue/"},{"name":"编译器","slug":"编译器","permalink":"http://www.helicunzai.cn/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"VIM","slug":"VIM","permalink":"http://www.helicunzai.cn/categories/VIM/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.helicunzai.cn/categories/JavaScript/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.helicunzai.cn/categories/SpringBoot/"},{"name":"C","slug":"C","permalink":"http://www.helicunzai.cn/categories/C/"},{"name":"Java","slug":"Java","permalink":"http://www.helicunzai.cn/categories/Java/"},{"name":"网站开发","slug":"网站开发","permalink":"http://www.helicunzai.cn/categories/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/categories/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://www.helicunzai.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Django","slug":"Django","permalink":"http://www.helicunzai.cn/categories/Django/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/categories/%E7%88%AC%E8%99%AB/"},{"name":"人工智能","slug":"人工智能","permalink":"http://www.helicunzai.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.helicunzai.cn/categories/OpenCV/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.helicunzai.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Qt","slug":"Qt","permalink":"http://www.helicunzai.cn/categories/Qt/"},{"name":"C++","slug":"C","permalink":"http://www.helicunzai.cn/categories/C/"}],"tags":[{"name":"微机原理与接口技术","slug":"微机原理与接口技术","permalink":"http://www.helicunzai.cn/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/"},{"name":"STM32","slug":"STM32","permalink":"http://www.helicunzai.cn/tags/STM32/"},{"name":"嵌入式","slug":"嵌入式","permalink":"http://www.helicunzai.cn/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"前端","slug":"前端","permalink":"http://www.helicunzai.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"ES6","slug":"ES6","permalink":"http://www.helicunzai.cn/tags/ES6/"},{"name":"CSS","slug":"CSS","permalink":"http://www.helicunzai.cn/tags/CSS/"},{"name":"Vue","slug":"Vue","permalink":"http://www.helicunzai.cn/tags/Vue/"},{"name":"GCC","slug":"GCC","permalink":"http://www.helicunzai.cn/tags/GCC/"},{"name":"VIM","slug":"VIM","permalink":"http://www.helicunzai.cn/tags/VIM/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.helicunzai.cn/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://www.helicunzai.cn/tags/jQuery/"},{"name":"Java","slug":"Java","permalink":"http://www.helicunzai.cn/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.helicunzai.cn/tags/SpringBoot/"},{"name":"C","slug":"C","permalink":"http://www.helicunzai.cn/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://www.helicunzai.cn/tags/Linux/"},{"name":"Python","slug":"Python","permalink":"http://www.helicunzai.cn/tags/Python/"},{"name":"网站开发","slug":"网站开发","permalink":"http://www.helicunzai.cn/tags/%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91/"},{"name":"Flask","slug":"Flask","permalink":"http://www.helicunzai.cn/tags/Flask/"},{"name":"机器学习","slug":"机器学习","permalink":"http://www.helicunzai.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"人工智能","slug":"人工智能","permalink":"http://www.helicunzai.cn/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"数据库","slug":"数据库","permalink":"http://www.helicunzai.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"网络编程","slug":"网络编程","permalink":"http://www.helicunzai.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"网站","slug":"网站","permalink":"http://www.helicunzai.cn/tags/%E7%BD%91%E7%AB%99/"},{"name":"Django","slug":"Django","permalink":"http://www.helicunzai.cn/tags/Django/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.helicunzai.cn/tags/%E7%88%AC%E8%99%AB/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://www.helicunzai.cn/tags/OpenCV/"},{"name":"计算机网路","slug":"计算机网路","permalink":"http://www.helicunzai.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/"},{"name":"C++","slug":"C","permalink":"http://www.helicunzai.cn/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://www.helicunzai.cn/tags/Qt/"},{"name":"算法","slug":"算法","permalink":"http://www.helicunzai.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"STL","slug":"STL","permalink":"http://www.helicunzai.cn/tags/STL/"},{"name":"OP编程","slug":"OP编程","permalink":"http://www.helicunzai.cn/tags/OP%E7%BC%96%E7%A8%8B/"}]}