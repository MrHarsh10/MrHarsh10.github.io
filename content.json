{"meta":{"title":"Mr Harsh的广阔天地","subtitle":"广阔天地，大有作为。","description":"广阔天地，大有作为。","author":"MrHarsh","url":"http://www.mrharsh.top","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-08-10T08:07:27.912Z","updated":"2022-08-10T08:07:27.912Z","comments":false,"path":"/404.html","permalink":"http://www.mrharsh.top/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-08-09T14:02:25.497Z","updated":"2022-08-09T14:02:25.495Z","comments":false,"path":"about/index.html","permalink":"http://www.mrharsh.top/about/index.html","excerpt":"","text":"所有的生活都是合理的,我们没必要相互理解。"},{"title":"分类","date":"2022-08-08T14:44:28.267Z","updated":"2022-08-08T14:44:28.266Z","comments":false,"path":"categories/index.html","permalink":"http://www.mrharsh.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-08-08T14:45:01.893Z","updated":"2022-08-08T14:45:01.893Z","comments":false,"path":"tags/index.html","permalink":"http://www.mrharsh.top/tags/index.html","excerpt":"","text":""},{"title":"Github仓库","date":"2022-08-08T11:11:17.332Z","updated":"2022-08-08T11:11:17.332Z","comments":false,"path":"repository/index.html","permalink":"http://www.mrharsh.top/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"win网络编程","slug":"win网络编程","date":"2022-08-18T14:11:58.000Z","updated":"2022-08-18T14:26:45.477Z","comments":true,"path":"2022/08/18/win网络编程/","link":"","permalink":"http://www.mrharsh.top/2022/08/18/win%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"WIN套接字编程设置头文件和库 Winsock初始化 12#include &lt;WinSock2.h&gt;int WSAStartup(_In_ WORD wVersionRequested,_Out_ LPWSADATA lpWSAData); 1234567891011121314#include &lt;WinSock2.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;windows.h&gt; int main()&#123; WSADATA wsadata; if (WSAStartup(MAKEWORD(2, 2), &amp;wsadata) != 0) &#123; exit(1); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"Python爬虫：爬取豆瓣电影榜Top250","slug":"Python爬虫：爬取豆瓣电影榜Top250","date":"2022-08-16T15:57:27.000Z","updated":"2022-08-16T17:16:23.767Z","comments":true,"path":"2022/08/16/Python爬虫：爬取豆瓣电影榜Top250/","link":"","permalink":"http://www.mrharsh.top/2022/08/16/Python%E7%88%AC%E8%99%AB%EF%BC%9A%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E6%A6%9CTop250/","excerpt":"","text":"前言 现在很多网站都做了反爬，导致单一使用requests库无法爬到东西，经过全网实验，我发现豆瓣的电影排行榜很容易爬取下来的 实现过程 我们使用浏览器检查工具 分析每一项的HTML代码 1234567891011121314151617181920212223242526272829303132333435363738&lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;pic&quot;&gt; &lt;em class=&quot;&quot;&gt;1&lt;/em&gt; &lt;a href=&quot;https://movie.douban.com/subject/1292052/&quot;&gt; &lt;img width=&quot;100&quot; alt=&quot;肖申克的救赎&quot; src=&quot;https://img2.doubanio.com/view/photo/s_ratio_poster/public/p480747492.jpg&quot; class=&quot;&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;info&quot;&gt; &lt;div class=&quot;hd&quot;&gt; &lt;a href=&quot;https://movie.douban.com/subject/1292052/&quot; class=&quot;&quot;&gt; &lt;span class=&quot;title&quot;&gt;肖申克的救赎&lt;/span&gt; &lt;span class=&quot;title&quot;&gt; / The Shawshank Redemption&lt;/span&gt; &lt;span class=&quot;other&quot;&gt; / 月黑高飞(港) / 刺激1995(台)&lt;/span&gt; &lt;/a&gt; &lt;span class=&quot;playable&quot;&gt;[可播放]&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;bd&quot;&gt; &lt;p class=&quot;&quot;&gt; 导演: 弗兰克·德拉邦特 Frank Darabont 主演: 蒂姆·罗宾斯 Tim Robbins /...&lt;br&gt; 1994 / 美国 / 犯罪 剧情 &lt;/p&gt; &lt;div class=&quot;star&quot;&gt; &lt;span class=&quot;rating5-t&quot;&gt;&lt;/span&gt; &lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;9.7&lt;/span&gt; &lt;span property=&quot;v:best&quot; content=&quot;10.0&quot;&gt;&lt;/span&gt; &lt;span&gt;2674333人评价&lt;/span&gt; &lt;/div&gt; &lt;p class=&quot;quote&quot;&gt; &lt;span class=&quot;inq&quot;&gt;希望让人自由。&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 每个代码都有如上规律，所以我们用正则表达式去匹配每个电影，获取需要的数据 这个需要有正则表达式知识 123pattern=re.compile( &#x27;&lt;div class=&quot;item&quot;&gt;.*?&lt;em class=&quot;&quot;&gt;(.*?)&lt;/em&gt;.*?&lt;span class=&quot;title&quot;&gt;(.*?)&lt;/span&gt;.*?&lt;br&gt;(.*?) / .*? / (.*?)&lt;/p&gt;.*?property=&quot;v:average&quot;&gt;(.*?)&lt;/span&gt;&#x27;,re.S) items=re.findall(pattern,html) 然后网站是以GET方式25为增量换页的 12https://movie.douban.com/top250?start=0&amp;filter=https://movie.douban.com/top250?start=25&amp;filter= 有了以上思路就可以完成爬虫了 代码 123456789101112131415161718192021222324252627282930313233343536373839import requests,re,csvdef getpage(url): headers=&#123; &#x27;User-Agent&#x27;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36 Edg/104.0.1293.54&quot; &#125; response=requests.get(url,headers=headers) if response.status_code==200: return response.text print(&quot;爬取失败&quot;) return Nonedef parsehtml(html): pattern=re.compile( &#x27;&lt;div class=&quot;item&quot;&gt;.*?&lt;em class=&quot;&quot;&gt;(.*?)&lt;/em&gt;.*?&lt;span class=&quot;title&quot;&gt;(.*?)&lt;/span&gt;.*?&lt;br&gt;(.*?) / .*? / (.*?)&lt;/p&gt;.*?property=&quot;v:average&quot;&gt;(.*?)&lt;/span&gt;&#x27;,re.S) items=re.findall(pattern,html) return items;def write(items): with open(&quot;豆瓣电影Top250.csv&quot;,mode=&quot;w&quot;, encoding=&quot;utf-8-sig&quot;, newline=&quot;&quot;) as f: writer = csv.writer(f) headerList=[&#x27;排名&#x27;,&#x27;电影名&#x27;,&#x27;上映时间&#x27;,&#x27;分类&#x27;,&#x27;豆瓣评分&#x27;] writer.writerow(headerList) for i in items: tmp=[] tmp.append(i[0]) tmp.append(i[1]) tmp.append(str(i[2]).strip()) tmp.append(str(i[3]).strip()) tmp.append(str(i[4]).strip()) print(tmp[0],tmp[1],tmp[2],tmp[3],tmp[4]) writer.writerow(tmp)def main(): items=[] for i in range(0,250,25): url=&#x27;https://movie.douban.com/top250?start=&#123;&#125;&amp;filter=&#x27;.format(i) text=getpage(url) items+=parsehtml(text) write(items)main() 结果 非常基础的爬虫入门例子","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.mrharsh.top/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.mrharsh.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.mrharsh.top/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Qt工具类","slug":"Qt工具类","date":"2022-08-14T02:34:48.000Z","updated":"2022-08-15T09:19:44.404Z","comments":true,"path":"2022/08/14/Qt工具类/","link":"","permalink":"http://www.mrharsh.top/2022/08/14/Qt%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"字符串类 操作字符串 “+” QString::append() QString::sprintf() 12QString str;str.sprintf(&quot; %s &quot;,&quot;hi&quot;); QString::arg() 12QString str;str=QString(&quot;%1 a %2&quot;).arg(&quot;1&quot;).arg(&quot;2&quot;); 组合字符串 insert() 插入字符串 prepend() 开头插入 replace() 替代 QString::trimmed() 移除两端的空白字符 QString::simplified() 移除两端的空白字符,使用单个空格字符代替空白字符 查询字符串 QString::startsWith() 12QString str=&quot;sddsa&quot;str.startsWith(&quot;s&quot;,Qt::CaseSensitive);// true QString::endsWith() 结尾 QString::contains() 包含 操作符 &gt;=&lt; 字符串转换 toInt() toAscii toLatin1() toUtf8() toLocal8Bit() 12345QString str=&quot;welcome to you&quot;;QByteArray b=str.toAscii();qDebug&lt;&lt;b;b.append(&quot;hello world&quot;);qDebug()&lt;&lt;ba.data(); 容器类 QList类 QList::append() QList::prepend() QList::insert() 123QList&lt;QString&gt;list;QString str(&quot;sdsd&quot;);list&lt;&lt;str; QLinkedList类 QLinkedList是一个链式列表，以非连续的内存块保存 QVector类 相邻的内存储存给定数据类型的一组数值 Java风格迭代器遍历容器 *两种不同类型的Java风格迭代器数据类型* 容器类 只读迭代器类 读写迭代器类 QList,QQueue QListIterator QMutableListIterator QLinkedList QLinkedListIterator QMutableLinkedListIterator QVector,QStack QVectorIterator QMutableVectorIterator 123456789101112#include &lt;QCoreApplication&gt;#include &lt;QDebug&gt;int main(int argc,char *argv[])&#123; QCoreApplication a(argc,argv); QList&lt;int&gt;list; list&lt;&lt;1&lt;&lt;2&lt;&lt;3&lt;&lt;4&lt;&lt;5; QListIterator&lt;int&gt;i(list); for(;i.hasNext();) qDebug()&lt;&lt;i.next; return a.exec;&#125; QListIterator QListIterator::toBack() QListIterator::hasPrevious() QListIterator::previous() QListIterator::toFront() QListIterator::peeknext() QListIterator::peekPrevious() QListIterator::findNext() QListIterator::findPrevious() STL风格迭代器遍历容器 STL风格迭代器数据类型* 容器类 只读迭代器类 读写迭代器类 QList QListIterator::const_iterator QListIterator::iterator QLinkedList QLinkedListIterator::const_iterator QLinkedListIterator::iterator QVector,QStack QVectorIterator::const_iterator QVector::iterator","categories":[{"name":"Qt","slug":"Qt","permalink":"http://www.mrharsh.top/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://www.mrharsh.top/tags/Qt/"},{"name":"C++","slug":"C","permalink":"http://www.mrharsh.top/tags/C/"}]},{"title":"requests库的使用","slug":"requests的使用","date":"2022-08-13T10:22:05.000Z","updated":"2022-08-13T13:31:39.393Z","comments":true,"path":"2022/08/13/requests的使用/","link":"","permalink":"http://www.mrharsh.top/2022/08/13/requests%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"请求 post(‘url’) put(‘url’) delete(‘url’) head(‘url’) options(‘url’) get(‘url’) GET请求 1234567891011import requestsfrom urllib.parse import urlencodedata=&#123; &#x27;name&#x27;:&#x27;hha&#x27;, &#x27;age&#x27;:&#x27;a&#x27;&#125;r=requests.get(&#x27;http://httpbin.org/get&#x27;,params=data)print(r.text)js=r.json()print(js[&quot;headers&quot;][&quot;User-Agent&quot;])r.text) 下载图片 1234import requestsr=requests.get(&#x27;https://s2.loli.net/2022/08/08/XPao6Bwfkjc2drg.jpg&#x27;)with open(&#x27;pic.jpg&#x27;,&#x27;wb&#x27;) as f: f.write(r.content) POST请求 123456import requestsdata=&#123; &quot;1&quot;:&quot;1&quot;&#125;r=requests.post(&#x27;http://httpbin.org/post&#x27;,data=data)print(r.text) 文件上传 123456import requestsfiles=&#123; &#x27;files&#x27;:open(&#x27;pic.jpg&#x27;,&#x27;rb&#x27;)&#125;r=requests.post(&#x27;http://httpbin.org/post&#x27;,files=files)print(r.text) 会话维持 12345import requestss=requests.session()s.get(&#x27;http://httpbin.org/cookies/set/number/12345&#x27;)r=s.get(&#x27;http://httpbin.org/cookies&#x27;)print(r.text)","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.mrharsh.top/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.mrharsh.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.mrharsh.top/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"刷题笔记㈠","slug":"刷题笔记㈠","date":"2022-08-11T13:10:25.000Z","updated":"2022-08-11T15:45:00.142Z","comments":true,"path":"2022/08/11/刷题笔记㈠/","link":"","permalink":"http://www.mrharsh.top/2022/08/11/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%88%A0/","excerpt":"","text":"额，感觉这很奇怪，下次不写了 面试题 08.05. 递归乘法 - 力扣（LeetCode） 思路： AB=MAX(MIN-1+1)=MAX*(MIN-1)+MAX 123456789101112class Solution &#123;public: int multiply(int A, int B) &#123; int Max=max(A,B); int Min=min(A,B); if(Min==0) return 0; else if(Min==1) return Max; return multiply(Min-1,Max)+Max; &#125;&#125;; 2119. 反转两次的数字 - 力扣（LeetCode） 老实人真会反转两次 123456class Solution &#123;public: int isSameAfterReversals(int num) &#123; return num == 0 || num % 10 != 0; &#125;&#125;; 剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode） 越界处理用取模 12345678910class Solution &#123;public: string reverseLeftWords(string s, int n) &#123; int len=s.length(); string str(s); for(int i=0;i&lt;len;i++) s[i]=str[(i+n)%len]; return s; &#125;&#125;; 136. 只出现一次的数字 - 力扣（LeetCode） 本题采用异或运算 异或运算性质 a^a=0； a^0=a; ab=ba 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans=0; for(int i=0;i&lt;nums.size();i++) ans^=nums[i]; return ans; &#125;&#125;; 268. 丢失的数字 - 力扣（LeetCode） 求和做减法 12345678910class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(); int sum=n*(n+1)/2; for(auto it:nums) sum-=it; return sum; &#125;&#125;; 剑指 Offer 53 - II. 0～n-1中缺失的数字 - 力扣（LeetCode） 123456789101112class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int ans=0; int n=nums.size()+1; for(int i=0;i&lt;n;i++) ans^=i; for(auto it:nums) ans^=it; return ans; &#125;&#125;;","categories":[{"name":"C++","slug":"C","permalink":"http://www.mrharsh.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.mrharsh.top/tags/C/"},{"name":"算法","slug":"算法","permalink":"http://www.mrharsh.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C++的STL","slug":"C-的STL","date":"2022-08-10T08:51:16.000Z","updated":"2022-08-11T09:56:39.691Z","comments":true,"path":"2022/08/10/C-的STL/","link":"","permalink":"http://www.mrharsh.top/2022/08/10/C-%E7%9A%84STL/","excerpt":"","text":"开始 STL的代码从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），几乎所有的代码都采用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说。 用STL我们就不用反复实现一些代码，提高开发效率。当然这个需要数据结构基础 vector动态数组 头文件 1#include &lt;vector&gt; 初始化 123456789101112vector&lt;int&gt; ans;//int的型的数组vector&lt;structure&gt; ans;//一个structure结构体的数组//指定长度的初始化vector&lt;short&gt; ans(n);vector&lt;double&gt; ans(n,2);//长度为n,全为2的数组vector&lt;double&gt; shaow(ans);//拷贝初始化，类型长度需相同vector&lt;int&gt; a&#123;1, 2, 3, 4, 5&#125;;//二维vector&lt;int&gt;ans[5];//行为固定的5，列为动态可变vector&lt;vectot&lt;int&gt; &gt;num;//行列均可以变vector&lt;vector&lt;int&gt; &gt; a(n + 1, vector&lt;int&gt;(m + 1, 0));//固定n+1行m+1列初始值为0的二维数组 访问遍历 123456789101112131415#include &lt;iostream&gt;#include &quot;vector&quot;using namespace std;int main() &#123; int n = 5; vector&lt;int&gt; num(5, 1); cout&lt;&lt;num[2];//访问下标为2的元素//智能指针遍历 for (auto i: num) cout &lt;&lt; i &lt;&lt; &quot; &quot;;//遍历 for(int i=0;i&lt;num.size();i++) cout&lt;&lt;num[i]&lt;&lt;&#x27; &#x27;; return 0;&#125; 方法函数 函数 含义 a.empty() 判断是否为空，空为真 a.begin() 返回首元素的迭代器 a.end() 返回末位元素的迭代器 a.size() 返回数据个数 a.insert(it,x) 先任意迭代器插入一个元素 a.push_back() 尾部添加一个 a.pop_back() 删除最后一个元素 a.front() 返回第一个数据 a.clear() 清除元素 a.resize(n,v) 改变数组大小为n,赋值为v a.erase(f,l) 删除[f,i)的所有元素 sort(a.begin(),a.end()) 排序 代码 12345678910#include &lt;iostream&gt;#include &quot;vector&quot;using namespace std;int main() &#123; int n = 5; vector&lt;int&gt; num(5, 1); for(vector&lt;int&gt;::iterator it=num.begin();it!=num.end();it++) cout&lt;&lt;*it&lt;&lt;&#x27; &#x27;; return 0;&#125; stack栈 头文件 1#include &lt;stack&gt; 初始化 1stack&lt;int&gt;ans; 方法函数 函数 含义 push() 压栈 pop() 出栈 empty() 空为真 top() 取得栈顶元素 size() 元素个数 代码 1234567891011121314#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; stack&lt;int&gt;a; int i; while(!a.empty()) &#123; i=a.top(); cout&lt;&lt;i&lt;&lt;&quot; &quot;; a.pop(); &#125; return 0;&#125; queue队列 头文件 1#include&lt;queue&gt; 初始化 1queue&lt;int&gt;ans; 方法函数 函数 含义 front() 返回队首 back() 返回队尾元素 pop() 出队 push() 进队 size() 元素个数 empty() 空队为空 代码 12345678910111213141516#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123; queue&lt;int&gt;a; for(int i=0;i&lt;10;i++) a.push(i); int i; while(!a.empty()) &#123; i=a.front(); cout&lt;&lt;i&lt;&lt;&#x27; &#x27;; a.pop(); &#125; return 0;&#125; deque双队列 头文件 1#include &lt;deque&gt; 初始化 1deque&lt;int&gt;ans; 方法函数 函数 含义 push_back()push_front() 入队 back()front() 访问 pop_back()pop_back() 出队 erase(iterator f,iterator l) 删除 empty() 空为真 size() 元素数量 clear() 清空 sort(iterator f,iterator l) 排序 代码 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;deque&gt;#include &quot;algorithm&quot;using namespace std;int main() &#123;deque&lt;int&gt;a;int b[5]=&#123;3,8,9,6,2&#125;;for(int i=0;i&lt;5;i++) a.push_front(b[i]);sort(a.begin(),a.end());int i;while(!a.empty())&#123; i=a.back(); cout&lt;&lt;i&lt;&lt;&#x27; &#x27;; a.pop_back();&#125; return 0;&#125; priority_queue优先队列 头文件 1#include&lt;queue&gt; 头文件 12#include &lt;map&gt;priority_queue&lt;Type, Container, Functional&gt; 方法函数 函数 含义 top() 队首元素 push() 入队 pop() 出队 empty() 空为真 size() 元素个数 代码 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main()&#123; priority_queue&lt;int&gt; a; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; c; //这样就是小顶堆 for (int i = 0; i &lt; 5; i++) &#123; a.push(i); c.push(i); &#125; while (!a.empty()) &#123; cout &lt;&lt; a.top() &lt;&lt; &#x27; &#x27;; a.pop(); &#125; cout &lt;&lt; endl; while (!c.empty()) &#123; cout &lt;&lt; c.top() &lt;&lt; &#x27; &#x27;; c.pop(); &#125; cout &lt;&lt; endl; return 0;&#125; map映射 头文件 1#include&lt;map&gt; 初始化 map&lt;string,int&gt;a; 函数方法 函数 含义 find(key) 返回键为key的映射的迭代器当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end() erase(it) 删除迭代器对应的键和值 erase(key) 根据映射的键删除键和值 erase(first,last) 删除左闭右开区间迭代器对应的键和值 size() 返回对数 clear() 清空所有元素 insert() 插入元素 empty() 是否为空 begin() 第一个元素的迭代器 end() 返回尾部的迭代器（最后一个元素的下一个地址） rbegin() 返回最后一个元素的迭代器（地址） rend() 返回第一个元素的迭代器 rend() 返回第一个元素的迭代器 count(key) 查看元素是否存在 lower_bound() 返回指向键值&gt;= key的第一个元素 upper_bound() 返回指向键值&gt; key的第一个元素的迭代器， 代码 1234567891011121314151617#include&lt;iostream&gt;#include &lt;map&gt;using namespace std;int main()&#123;map&lt;int,string&gt;a;a[1]=&quot;hello&quot;;a[2]=&quot;hi&quot;;cout&lt;&lt;a[1];cout&lt;&lt;endl; map&lt;int,string&gt;::iterator it; for(it=a.begin();it!=a.end();it++) cout&lt;&lt;it-&gt;first&lt;&lt;&#x27;:&#x27;&lt;&lt;it-&gt;second&lt;&lt;endl; for(auto i:a) cout&lt;&lt;i.first&lt;&lt;&quot;:&quot;&lt;&lt;i.second&lt;&lt;endl; return 0;&#125; set集合 集合不重合且有序 头文件 1#include &lt;set&gt; 方法函数 函数 含义 begin() 返回第一个元素的迭代器 end() 返回最后一个元素的迭代器 rbegin() 返回逆序迭代器 rend() 返回逆序迭代器 clear() 删除set容器中的所有的元素 empty() 判断是否为空 insert() 插入一个元素 size() 容器中的元素个数 erase(iterator)erase(first,second） 删除指向的值 erase(key_value) 删除键值key_value的值 find(元素) 查找set中的某一元素，返回迭代器 lower_bound(k) 返回大于等于k的第一个元素的迭代器 upper_bound(k) 返回大于k的第一个元素的迭代器 代码 123456789101112131415161718#include&lt;iostream&gt;#include &lt;set&gt;using namespace std;int main()&#123; set&lt;int&gt;a; a.insert(8); a.insert(3); a.insert(9); a.insert(7); a.insert(6); a.insert(5); for(set&lt;int&gt;::iterator it=a.begin();it!=a.end();it++) cout&lt;&lt;*it&lt;&lt;&quot; &quot;; return 0;&#125;//结果为3 5 6 7 8 9 pair对组 pair只含有两个元素，可以看作是只有两个元素的结构体. 头文件 1#include&lt;utility&gt; 字符串 头文件 1#include &lt;string&gt; 初始化 12345678string str1; //生成空字符串string str2(&quot;123456789&quot;); //生成&quot;1234456789&quot;的复制品 string str3(&quot;12345&quot;, 0, 3);//结果为&quot;123&quot; ，从0位置开始，长度为3string str4(&quot;123456&quot;, 5); //结果为&quot;12345&quot; ，长度为5string str5(5, &#x27;2&#x27;); //结果为&quot;22222&quot; ,构造5个字符&#x27;2&#x27;连接而成的字符串string str6(str2, 2); //结果为&quot;3456789&quot;，截取第三个元素（2对应第三位）到最后 函数方法 函数 含义 sort(s.begin(),s.end()); 排序 size()length() 长度 max_size() 返回string对象最多包含的字符数 capacity() 重新分配内存之前，string对象能包含的最大字符数 push_back() 末尾插入 insert(pos,element) 插入 append(str) 末尾添加字符串 erase(it)erase(iterator p) 删除指定字符 erase(iterator first, iterator last) 删除字符串中迭代器区间所有字符 clear() 清空 replace(pos,n,str) 把当前字符串从索引pos开始的n个字符替换为str replace(pos,n,x,c) 把当前字符串从索引pos开始的n个字符替换为x个字符c replace(it1,it2,str) 把当前字符串[it1,it2)区间替换为str tolower() 转换为小写 toupper() 转换为大写 substr(pos,n) 截取从pos索引开始的n个字符 find (str, pos)find (c, pos) 在当前字符串的pos索引位置(默认为0)开始，查找子串str，返回找到的位置索引，-1表示查找不到子串 rfind (str, pos) 在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引 find_first_of (str, pos) 在当前字符串的pos索引位置(默认为0)开始，查找子串s的字符 .find_first_not_of (str,pos) 在当前字符串的pos索引位置(默认为0)开始，查找第一个不位于子串s的字符 find_last_of(str, pos) 当前字符串的pos索引位置开始，查找最后一个位于子串s的字符 find_last_not_of ( str, pos) 在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符 bitsei位组 头文件 1#include &lt;bitset&gt; 初始化 1234bitset &lt; n &gt;a; //a有n位，每位都为0bitset &lt; n &gt;a(b);bitset &lt; n &gt;a(s,pos,n);//a是s中从位置pos开始的n个位的副本bitset &lt; n &gt;a(s); 函数方法 函数 含义 any() 是否存在置为1的二进制位，有返回true none() b中是否没有1 count() 1的个数 size() 二进制位的个数 test(pos) 在pos位置是否为1，是返回true b.set() 所有位都置为1 reset() 所有位都置为0 reset(pos) pos位置置为0 flip() 所有二进制位取反 flip(pos) pos位置取反 to_ulong() 同样的二进制位返回一个unsigned long值 bitset也支持位运算 array数组 头文件 1#include &lt;array&gt; 初始化 1234array&lt;int, 100&gt; a;//声明一个大小为100的int型数组array&lt;int, 100&gt; a&#123;&#125;;//声明一个大小为100的int型数组，初始值均为0array&lt;int, 100&gt; a&#123;1, 2, 3&#125;;//始化部分值，其余全部为0array&lt;int, 100&gt; a = &#123;1, 2, 3&#125;; 访问遍历 12345678910111213array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;for(int i = 0; i &lt; 4; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; \\n&quot;[i == 3];//迭代器for(auto i : a) cout &lt;&lt; i &lt;&lt; &quot; &quot;;//at访问array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;int res = a.at(1) + a.at(2);cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;;get&lt;1&gt;(a) = x;//将a数组下标为1位置处的值改为x 方法函数 函数 含义 begin() 第一个元素的访问迭代器 end() 返回容器最后一个元素之后一个位置的访问迭代器 rbegin() 返回最后一个元素的访问迭代器 rend() 返回第一个元素之前一个位置的访问迭代器 size() 返回容器中元素的数量 max_size() 返回容器可容纳元素的最大数量 empty() 判断容器是否为空 at(n) 返回容器中 n 位置处元素的引用 front() 返回容器中第一个元素的直接引用 back() 返回容器中最后一个元素的直接引用 data() 返回一个指向容器首个元素的指针 fill(x) 将 x 这个值赋值给容器中的每个元素,相当于初始化 array1.swap(array2) 交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型 sort() 排序 tuple元组 头文件 1#include &lt;tuple&gt; 初始化 1234567tuple&lt;int, int, string&gt; t1;//声明一个空的tuple三元组t1 = make_tuple(1, 1, &quot;hahaha&quot;);tuple&lt;int, int, int, int&gt; t2(1, 2, 3, 4);auto p = make_pair(&quot;wang&quot;, 1);tuple&lt;string, int&gt; t3 &#123;p&#125;; //将pair对象赋给tuple对象 操作 读取修改 12int first = get&lt;0&gt;(t);get&lt;0&gt;(t) = 1; 获取元素个数 12tuple&lt;int, int, int&gt; t(1, 2, 3);cout &lt;&lt; tuple_size&lt;decltype(t)&gt;::value &lt;&lt; &quot;\\n&quot;; // 3 解包 12345int one, three;string two; tuple&lt;int, string, int&gt; t(1, &quot;hahaha&quot;, 3);tie(one, two, three) = t;cout &lt;&lt; one &lt;&lt; two &lt;&lt; three &lt;&lt; &quot;\\n&quot;; // 1hahaha3","categories":[{"name":"C++","slug":"C","permalink":"http://www.mrharsh.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.mrharsh.top/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://www.mrharsh.top/tags/STL/"}]},{"title":"C++编程","slug":"C-编程","date":"2022-08-10T03:28:35.000Z","updated":"2022-08-10T03:34:26.204Z","comments":true,"path":"2022/08/10/C-编程/","link":"","permalink":"http://www.mrharsh.top/2022/08/10/C-%E7%BC%96%E7%A8%8B/","excerpt":"","text":"从C到C++ C是面向过程的语言，对于小规模程序还是得心应手的，为了程序设计的更见简易，C++最为C语言的自增版，保留原来语法，增加面向对象机制。","categories":[{"name":"C++","slug":"C","permalink":"http://www.mrharsh.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.mrharsh.top/tags/C/"},{"name":"OP编程","slug":"OP编程","permalink":"http://www.mrharsh.top/tags/OP%E7%BC%96%E7%A8%8B/"}]},{"title":"urllib库的使用","slug":"urllib库的使用","date":"2022-08-09T06:51:35.000Z","updated":"2022-08-13T10:11:19.764Z","comments":true,"path":"2022/08/09/urllib库的使用/","link":"","permalink":"http://www.mrharsh.top/2022/08/09/urllib%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"开始 urllib是Python内置的HTTP请求模块，其包含以下四个模块 request:HTTP请求模块 error:异常处理模块 parse:工具模块，拆分、解析、合并 robotparser:识别网站robots.txt文件，判断哪些网站可以爬。 请求发送 urlopen() 123456import urllib.requestresponse=urllib.request.urlopen(&#x27;https://www.baidu.com&#x27;)print(response.read().decode(&#x27;utf-8&#x27;))#read可以返回网页内容， 网页编码为UTF-8需要用decode,不然会有转义字符print(type(response)) #类型print(response.status) #获取响应状态码print(response.getheaders()) #获取响应头rs()) data参数 data参数为可选，使用需要，使用bytes()转换为字节流编码格式 12345import urllib.requestimport urllib.parsedata=bytes(urllib.parse.urlencode(&#123;&#x27;B&#x27;:&#x27;1&#x27;&#125;),encoding=&#x27;utf-8&#x27;)response=urllib.request.urlopen(&#x27;http://httpbin.org/post&#x27;,data=data)print(response.read().decode(&#x27;utf8&#x27;)) 我们的数据出现在了form字段里，这是我们用POST方法传递的数据 timeout参数 12345678import urllib.requestimport sockettry: response=urllib.request.urlopen(&#x27;http://www.google.com&#x27;,timeout=1) print(response.read().decode(&#x27;utf-8&#x27;))except urllib.error.URLError as e: if isinstance(e.reason,socket.timeout): print(&#x27;TIME OUT&#x27;) Request() urllib.request — Extensible library for opening URLs — Python 3.10.6 documentation Request能实现更多参数的请求 123def __init__(self, url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None): URL:请求URL data:必须为bytes(),如果是字典可以用urllib.parse.urlencode() headers:为一个字典 origin_req_host：表示这个请求是否是无法验证的 method:请求方法 123456789101112131415161718from urllib import request,parseurl=&#x27;http://httpbin.org/post&#x27;headers=&#123; &#x27;Host&#x27;:&#x27;httpbin.org&#x27;, &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36 Edg/104.0.1293.47&#x27;&#125;dict=&#123;&#x27;b&#x27;:1&#125;data=bytes(parse.urlencode(dict),encoding=&#x27;utf8&#x27;)data=bytes(parse.urlencode(&#123;&#x27;B&#x27;:&#x27;1&#x27;&#125;),encoding=&#x27;utf-8&#x27;)req=request.Request(url,data=data,headers=headers,method=&#x27;POST&#x27;)&quot;&quot;&quot;另一种请求头的添加方式req=request.Request(url=url,data=data,method=&#x27;POST&#x27;)req.add_header(&#x27;Host&#x27;,&#x27;httpbin.org&#x27;,)&quot;&quot;&quot;response=request.urlopen(req)print(response.read().deco 进阶用法 Handler 现在我们介绍Handler 比如： HTTPDefaultErrorHandler:用于处理响应错误，错误会抛出HTTPError类型的异常 HTTPRedirectHandler:处理重定向 HTTPCookieProcesser:处理Cookies ProxyHandler:设置代理，默认代理为空 HTTPPasswordMgr:用于管理密码，维护了用户名和密码 HTTPBasicAuthHandler:用于管理认证 Cookies 1234567import http.cookiejar,urllib.requestfilename=&#x27;cookies.txt&#x27;cookie=http.cookiejar.MozillaCookieJar(filename)handler=urllib.request.HTTPCookieProcessor(cookie)opener=urllib.request.build_opener(handler)response=opener.open(&#x27;http://www.baidu.com&#x27;)cookie.save(ignore_discard=True,ignore_expires=True) 1234567import http.cookiejar,urllib.requestcookie=http.cookiejar.CookieJar()handler=urllib.request.HTTPCookieProcessor(cookie)opener=urllib.request.build_opener(handler)response=opener.open(&#x27;http://www.baidu.com&#x27;)for item in cookie: print(item. 1234567import http.cookiejar,urllib.requestcookie=http.cookiejar.LWPCookieJar()cookie.load(&#x27;cookies.txt&#x27;,ignore_expires=1,ignore_discard=1)handler=urllib.request.HTTPCookieProcessor(cookie)opener=urllib.request.build_opener(handler)response=opener.open(&#x27;http://www.baidu.com&#x27;)print(response.read.decode(&#x27;utf-8&#x27;)) 异常处理 URLError 12345from urllib import request,errortry: response=request.urlopen(&#x27;http://mrharsh.top/index.htm&#x27;)except error.URLError as e: print(e.reason) HTTPError 1234567from urllib import request,errortry: response=request.urlopen(&#x27;http://mrharsh.top/index.htm&#x27;)except error.HTTPError as e: print(e.reason) print(e.code) URLError是HTTPError的父类 1234567891011from urllib import request,errortry: response=request.urlopen(&#x27;http://mrharsh.top/index.htm&#x27;)except error.HTTPError as e: print(e.reason) print(e.code)except error.URLError as e: print(e.reason)else: print(&#x27;SUCCESS!!&#x27;) 解析链接 urlparse 123from urllib.parse import urlparseresult=urlparse(&#x27;https://www.baidu.com/s?wd=%E7%89%B9%E6%9C%97%E6%99%AE%E6%88%96%E5%B0%86%E9%9D%A2%E4%B8%B4%E6%9C%80%E9%AB%9830%E5%B9%B4%E5%88%91%E6%9C%9F&amp;tn=baiduhome_pg&amp;usm=1&amp;rsv_idx=2&amp;ie=utf-8&amp;rsv_pq=beff06110014fb0c&amp;oq=%E9%BB%91%E5%B1%B1%E5%8F%91%E7%94%9F%E6%9E%AA%E5%87%BB%E4%BA%8B%E4%BB%B6%E8%87%B411%E6%AD%BB6%E4%BC%A4&amp;rsv_t=203cnvqhWV3frPIJkl4SxrljZIVFGNv6ZJkChXgM4YBU2qiBwG0dd0rTfPGYEJdqPkDg&amp;rqid=beff06110014fb0c&amp;rsf=a7183c00b74706d91bca215ee108b466_1_15_2&amp;rsv_dl=0_right_fyb_pchot_20811&amp;sa=0_right_fyb_pchot_20811&#x27;)print(result) urlunparse() 123from urllib.parse import urlunparsedata=[&#x27;https&#x27;,&#x27;wwww.baidu.com&#x27;,&#x27;index.html&#x27;,&#x27;user&#x27;,&#x27;a=6&#x27;,&#x27;comment&#x27;]print(urlunparse(data)) urlsplit 1234from urllib.parse import urlsplitresult=urlsplit(&#x27;https://www.baidu.com/s?wd=python&amp;pn=10&amp;oq=python&amp;tn=baiduhome_pg&amp;ie=utf-8&amp;usm=4&amp;rsv_idx=2&amp;rsv_pq=cb482fb3002cef17&amp;rsv_t=6415j2DcN1b3Ov7Yj0M6vjanBErrN6Meq3YKeNQ%2BhsGLzD1xnsUAYddpkN%2FlYnFdsQ07&#x27;)for i in result: print(i) urlunsplit() 123from urllib.parse import urlunsplitdata=[&#x27;http&#x27;,&#x27;www.baidu.com&#x27;,&#x27;index.html&#x27;,&#x27;a=0&#x27;,&#x27;c&#x27;]print(urlunsplit(data)) urljoin() 12from urllib.parse import urljoinprint(urljoin(&#x27;http://www.baidu.com&#x27;,&#x27;index.html&#x27;)) urlencode 在GET中加参数 12345678from urllib.parse import urlencodeparams=&#123; &#x27;name&#x27;:&#x27;s&#x27;, &quot;1&quot;:&quot;2&quot;&#125;base_url=&#x27;http//www.baidu.com&#x27;urll=base_url+urlencode(params)print(urll) parse_qs() 反序列化 1234from urllib.parse import urlsplit,parse_qsresult=urlsplit(&#x27;https://www.baidu.com/s?wd=python&amp;pn=10&amp;oq=python&amp;tn=baiduhome_pg&amp;ie=utf-8&amp;usm=4&amp;rsv_idx=2&amp;rsv_pq=cb482fb3002cef17&amp;rsv_t=6415j2DcN1b3Ov7Yj0M6vjanBErrN6Meq3YKeNQ%2BhsGLzD1xnsUAYddpkN%2FlYnFdsQ07&#x27;)print(parse_qs(result.query)) quote() 将内容转为URL编码 1234from urllib.parse import quote,urljoinkeyword=&#x27;python&#x27;url=&#x27;http://www.baidu.com/s?wd=&#x27;+quote(keyword)print(url) unquote() 12345from urllib.parse import quote,urljoin,unquotekeyword=&#x27;你好&#x27;url=&#x27;https://www.baidu.com/s?wd=&#x27;+quote(keyword)print(url)print(unquote(url)) Robots协议 robotparser() set_ur():设置Robots.txt链接 read():读取robots.txt并分析 parse():解析robots.txt文件 can_fetch():传入User-Agent和URL,判读是否可爬取 mtime():返回上次抓取的时间 modified():设置当前时间为上次抓取时间 123456from urllib.robotparser import RobotFileParserrp=RobotFileParser()rp.set_url(&#x27;https://www.bilibili.com/robots.txt&#x27;)rp.read()print(rp.can_fetch(&#x27;Yisouspider&#x27;,&#x27;https://www.bilibili.com/video/BV1fN4y1u7s1?spm_id_from=333.1007.tianma.2-3-6.click&#x27;))print(rp.can_fetch(&#x27;*&#x27;,&#x27;https://www.bilibili.com/video/BV1fN4y1u7s1?spm_id_from=333.1007.tianma.2-3-6.click&#x27;))","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.mrharsh.top/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.mrharsh.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.mrharsh.top/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"爬虫基础","slug":"爬虫基础","date":"2022-08-09T02:48:02.000Z","updated":"2022-08-09T05:36:50.356Z","comments":true,"path":"2022/08/09/爬虫基础/","link":"","permalink":"http://www.mrharsh.top/2022/08/09/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/","excerpt":"","text":"HTTP基本原理 参考资料： HTTP 教程 | 菜鸟教程 (runoob.com) URI和URL URI:统一资源标识符 URL:统一资源定位符 URN:统一资源名称 现在互联网，URN用得很少，一般网页链接🔗称为URL 超文本 网页源代码HTML称为超文本 HTTP和HTTPS HTTP:超文本传输协议 HTTPS:HTTP下加入SSL层 HTTP 请求过程 我们利用浏览器”检查“工具的网络来观察这个过程 General部分 Request URL:请求的URL Request Method:请求方法 Status Code: 响应状态码 Remote Address:远程服务器的地址和端口 Referrer Policy:Referrer判别策略 Response Header:响应头 Request Header:请求头 请求 请求由客户端发出，分为4部分 请求方法:Request Method 请求网址:Request URL 请求头:Request Headers 请求体:Request Body 请求方法 常见的为：GET和POST GET 与POST区别 GET的参数在URL里面，而POST请求的数据以表单传输，包含在请求体 GET的数据只有1024字节，而POST没有限制 其他请求方法 请求的网址 请求的网址即URL 请求头 Accept:请求报头域，指定客户端接收哪些类型的信息 Accept-Language:指定客户端可接受语言类型 Host:指定请求资源的主机IP和端口 Cookie:储存在用户本地终端上的数据,特定的 web文档关联在一起, 保存了该客户机访问这个Web 文档时的信息, 当客户机再次访问这个 Web 文档时这些信息可供该文档使用。 Referer:标识请求是从那个页面发过来的 User-Agent:一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。 Content-Type:内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件 请求体 请求体承载的是POST的表单数据，对于GET，请求为空 响应 响应状态码 常见的 HTTP 状态码： 200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误 其它可以参考HTTP 状态码 | 菜鸟教程 响应头 响应头包含服务器对请求的应答信息，如Content-Type、Sever、Set-Cookie 响应体 响应体包含响应的正文数据 网页基础 网页组成 网页是由HTML、CSS、JavaScript组成 如果想学爬虫，必须要点Web基础","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.mrharsh.top/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.mrharsh.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.mrharsh.top/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-08-07T17:38:10.230Z","updated":"2022-08-08T14:03:31.441Z","comments":true,"path":"2022/08/08/hello-world/","link":"","permalink":"http://www.mrharsh.top/2022/08/08/hello-world/","excerpt":"","text":"在Hexo上写文章 以前我是有写博客的用的是wordpress，wp可以说非常优秀，各种插件与主题，个性化也是非常的高，就是写博客就要有专门的时间写博客，而现在我发现hexo可以用markdown边写笔记，加个header就可以博客文章了，很方便！ Hello World 就让一句&quot;Hello world&quot;来开始新的旅程！","categories":[{"name":"随想","slug":"随想","permalink":"http://www.mrharsh.top/categories/%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"随想","slug":"随想","permalink":"http://www.mrharsh.top/tags/%E9%9A%8F%E6%83%B3/"}]}],"categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.mrharsh.top/categories/%E7%88%AC%E8%99%AB/"},{"name":"Qt","slug":"Qt","permalink":"http://www.mrharsh.top/categories/Qt/"},{"name":"C++","slug":"C","permalink":"http://www.mrharsh.top/categories/C/"},{"name":"随想","slug":"随想","permalink":"http://www.mrharsh.top/categories/%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.mrharsh.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.mrharsh.top/tags/%E7%88%AC%E8%99%AB/"},{"name":"Qt","slug":"Qt","permalink":"http://www.mrharsh.top/tags/Qt/"},{"name":"C++","slug":"C","permalink":"http://www.mrharsh.top/tags/C/"},{"name":"算法","slug":"算法","permalink":"http://www.mrharsh.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"STL","slug":"STL","permalink":"http://www.mrharsh.top/tags/STL/"},{"name":"OP编程","slug":"OP编程","permalink":"http://www.mrharsh.top/tags/OP%E7%BC%96%E7%A8%8B/"},{"name":"随想","slug":"随想","permalink":"http://www.mrharsh.top/tags/%E9%9A%8F%E6%83%B3/"}]}