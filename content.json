{"meta":{"title":"Mr Harsh的广阔天地","subtitle":"广阔天地，大有作为。","description":"广阔天地，大有作为。","author":"MrHarsh","url":"http://www.mrharsh.top","root":"/"},"pages":[{"title":"分类","date":"2022-08-08T14:44:28.267Z","updated":"2022-08-08T14:44:28.266Z","comments":false,"path":"categories/index.html","permalink":"http://www.mrharsh.top/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2022-08-10T08:07:27.912Z","updated":"2022-08-10T08:07:27.912Z","comments":false,"path":"/404.html","permalink":"http://www.mrharsh.top/404.html","excerpt":"","text":""},{"title":"Github仓库","date":"2022-08-08T11:11:17.332Z","updated":"2022-08-08T11:11:17.332Z","comments":false,"path":"repository/index.html","permalink":"http://www.mrharsh.top/repository/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-08-09T14:02:25.497Z","updated":"2022-08-09T14:02:25.495Z","comments":false,"path":"about/index.html","permalink":"http://www.mrharsh.top/about/index.html","excerpt":"","text":"所有的生活都是合理的,我们没必要相互理解。"},{"title":"标签","date":"2022-08-08T14:45:01.893Z","updated":"2022-08-08T14:45:01.893Z","comments":false,"path":"tags/index.html","permalink":"http://www.mrharsh.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"刷题笔记㈠","slug":"刷题笔记㈠","date":"2022-08-11T13:10:25.000Z","updated":"2022-08-11T15:36:51.507Z","comments":true,"path":"2022/08/11/刷题笔记㈠/","link":"","permalink":"http://www.mrharsh.top/2022/08/11/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%88%A0/","excerpt":"","text":"额，感觉这很奇怪，下次不写了 面试题 08.05. 递归乘法 - 力扣（LeetCode） 思路： AB=MAX(MIN-1+1)=MAX*(MIN-1)+MAX 123456789101112class Solution &#123;public: int multiply(int A, int B) &#123; int Max=max(A,B); int Min=min(A,B); if(Min==0) return 0; else if(Min==1) return Max; return multiply(Min-1,Max)+Max; &#125;&#125;; 2119. 反转两次的数字 - 力扣（LeetCode） 老实人真会反转两次 123456class Solution &#123;public: int isSameAfterReversals(int num) &#123; return num == 0 || num % 10 != 0; &#125;&#125;; 剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode） 越界处理用取模 12345678910class Solution &#123;public: string reverseLeftWords(string s, int n) &#123; int len=s.length(); string str(s); for(int i=0;i&lt;len;i++) s[i]=str[(i+n)%len]; return s; &#125;&#125;; 136. 只出现一次的数字 - 力扣（LeetCode） 本题采用异或运算 异或运算性质 a^a=0； a^0=a; ab=ba 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans=0; for(int i=0;i&lt;nums.size();i++) ans^=nums[i]; return ans; &#125;&#125;; 268. 丢失的数字 - 力扣（LeetCode） 求和做减法 12345678910class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int n=nums.size(); int sum=n*(n+1)/2; for(auto it:nums) sum-=it; return sum; &#125;&#125;; 剑指 Offer 53 - II. 0～n-1中缺失的数字 - 力扣（LeetCode） 123456789101112class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int ans=0; int n=nums.size()+1; for(int i=0;i&lt;n;i++) ans^=i; for(auto it:nums) ans^=it; return ans; &#125;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://www.mrharsh.top/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.mrharsh.top/tags/C/"},{"name":"算法","slug":"算法","permalink":"http://www.mrharsh.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C++的STL","slug":"C-的STL","date":"2022-08-10T08:51:16.000Z","updated":"2022-08-11T09:56:39.691Z","comments":true,"path":"2022/08/10/C-的STL/","link":"","permalink":"http://www.mrharsh.top/2022/08/10/C-%E7%9A%84STL/","excerpt":"","text":"开始 STL的代码从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），几乎所有的代码都采用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说。 用STL我们就不用反复实现一些代码，提高开发效率。当然这个需要数据结构基础 vector动态数组 头文件 1#include &lt;vector&gt; 初始化 123456789101112vector&lt;int&gt; ans;//int的型的数组vector&lt;structure&gt; ans;//一个structure结构体的数组//指定长度的初始化vector&lt;short&gt; ans(n);vector&lt;double&gt; ans(n,2);//长度为n,全为2的数组vector&lt;double&gt; shaow(ans);//拷贝初始化，类型长度需相同vector&lt;int&gt; a&#123;1, 2, 3, 4, 5&#125;;//二维vector&lt;int&gt;ans[5];//行为固定的5，列为动态可变vector&lt;vectot&lt;int&gt; &gt;num;//行列均可以变vector&lt;vector&lt;int&gt; &gt; a(n + 1, vector&lt;int&gt;(m + 1, 0));//固定n+1行m+1列初始值为0的二维数组 访问遍历 123456789101112131415#include &lt;iostream&gt;#include &quot;vector&quot;using namespace std;int main() &#123; int n = 5; vector&lt;int&gt; num(5, 1); cout&lt;&lt;num[2];//访问下标为2的元素//智能指针遍历 for (auto i: num) cout &lt;&lt; i &lt;&lt; &quot; &quot;;//遍历 for(int i=0;i&lt;num.size();i++) cout&lt;&lt;num[i]&lt;&lt;&#x27; &#x27;; return 0;&#125; 方法函数 函数 含义 a.empty() 判断是否为空，空为真 a.begin() 返回首元素的迭代器 a.end() 返回末位元素的迭代器 a.size() 返回数据个数 a.insert(it,x) 先任意迭代器插入一个元素 a.push_back() 尾部添加一个 a.pop_back() 删除最后一个元素 a.front() 返回第一个数据 a.clear() 清除元素 a.resize(n,v) 改变数组大小为n,赋值为v a.erase(f,l) 删除[f,i)的所有元素 sort(a.begin(),a.end()) 排序 代码 12345678910#include &lt;iostream&gt;#include &quot;vector&quot;using namespace std;int main() &#123; int n = 5; vector&lt;int&gt; num(5, 1); for(vector&lt;int&gt;::iterator it=num.begin();it!=num.end();it++) cout&lt;&lt;*it&lt;&lt;&#x27; &#x27;; return 0;&#125; stack栈 头文件 1#include &lt;stack&gt; 初始化 1stack&lt;int&gt;ans; 方法函数 函数 含义 push() 压栈 pop() 出栈 empty() 空为真 top() 取得栈顶元素 size() 元素个数 代码 1234567891011121314#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; stack&lt;int&gt;a; int i; while(!a.empty()) &#123; i=a.top(); cout&lt;&lt;i&lt;&lt;&quot; &quot;; a.pop(); &#125; return 0;&#125; queue队列 头文件 1#include&lt;queue&gt; 初始化 1queue&lt;int&gt;ans; 方法函数 函数 含义 front() 返回队首 back() 返回队尾元素 pop() 出队 push() 进队 size() 元素个数 empty() 空队为空 代码 12345678910111213141516#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123; queue&lt;int&gt;a; for(int i=0;i&lt;10;i++) a.push(i); int i; while(!a.empty()) &#123; i=a.front(); cout&lt;&lt;i&lt;&lt;&#x27; &#x27;; a.pop(); &#125; return 0;&#125; deque双队列 头文件 1#include &lt;deque&gt; 初始化 1deque&lt;int&gt;ans; 方法函数 函数 含义 push_back()push_front() 入队 back()front() 访问 pop_back()pop_back() 出队 erase(iterator f,iterator l) 删除 empty() 空为真 size() 元素数量 clear() 清空 sort(iterator f,iterator l) 排序 代码 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;deque&gt;#include &quot;algorithm&quot;using namespace std;int main() &#123;deque&lt;int&gt;a;int b[5]=&#123;3,8,9,6,2&#125;;for(int i=0;i&lt;5;i++) a.push_front(b[i]);sort(a.begin(),a.end());int i;while(!a.empty())&#123; i=a.back(); cout&lt;&lt;i&lt;&lt;&#x27; &#x27;; a.pop_back();&#125; return 0;&#125; priority_queue优先队列 头文件 1#include&lt;queue&gt; 头文件 12#include &lt;map&gt;priority_queue&lt;Type, Container, Functional&gt; 方法函数 函数 含义 top() 队首元素 push() 入队 pop() 出队 empty() 空为真 size() 元素个数 代码 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main()&#123; priority_queue&lt;int&gt; a; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; c; //这样就是小顶堆 for (int i = 0; i &lt; 5; i++) &#123; a.push(i); c.push(i); &#125; while (!a.empty()) &#123; cout &lt;&lt; a.top() &lt;&lt; &#x27; &#x27;; a.pop(); &#125; cout &lt;&lt; endl; while (!c.empty()) &#123; cout &lt;&lt; c.top() &lt;&lt; &#x27; &#x27;; c.pop(); &#125; cout &lt;&lt; endl; return 0;&#125; map映射 头文件 1#include&lt;map&gt; 初始化 map&lt;string,int&gt;a; 函数方法 函数 含义 find(key) 返回键为key的映射的迭代器当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回mp.end() erase(it) 删除迭代器对应的键和值 erase(key) 根据映射的键删除键和值 erase(first,last) 删除左闭右开区间迭代器对应的键和值 size() 返回对数 clear() 清空所有元素 insert() 插入元素 empty() 是否为空 begin() 第一个元素的迭代器 end() 返回尾部的迭代器（最后一个元素的下一个地址） rbegin() 返回最后一个元素的迭代器（地址） rend() 返回第一个元素的迭代器 rend() 返回第一个元素的迭代器 count(key) 查看元素是否存在 lower_bound() 返回指向键值&gt;= key的第一个元素 upper_bound() 返回指向键值&gt; key的第一个元素的迭代器， 代码 1234567891011121314151617#include&lt;iostream&gt;#include &lt;map&gt;using namespace std;int main()&#123;map&lt;int,string&gt;a;a[1]=&quot;hello&quot;;a[2]=&quot;hi&quot;;cout&lt;&lt;a[1];cout&lt;&lt;endl; map&lt;int,string&gt;::iterator it; for(it=a.begin();it!=a.end();it++) cout&lt;&lt;it-&gt;first&lt;&lt;&#x27;:&#x27;&lt;&lt;it-&gt;second&lt;&lt;endl; for(auto i:a) cout&lt;&lt;i.first&lt;&lt;&quot;:&quot;&lt;&lt;i.second&lt;&lt;endl; return 0;&#125; set集合 集合不重合且有序 头文件 1#include &lt;set&gt; 方法函数 函数 含义 begin() 返回第一个元素的迭代器 end() 返回最后一个元素的迭代器 rbegin() 返回逆序迭代器 rend() 返回逆序迭代器 clear() 删除set容器中的所有的元素 empty() 判断是否为空 insert() 插入一个元素 size() 容器中的元素个数 erase(iterator)erase(first,second） 删除指向的值 erase(key_value) 删除键值key_value的值 find(元素) 查找set中的某一元素，返回迭代器 lower_bound(k) 返回大于等于k的第一个元素的迭代器 upper_bound(k) 返回大于k的第一个元素的迭代器 代码 123456789101112131415161718#include&lt;iostream&gt;#include &lt;set&gt;using namespace std;int main()&#123; set&lt;int&gt;a; a.insert(8); a.insert(3); a.insert(9); a.insert(7); a.insert(6); a.insert(5); for(set&lt;int&gt;::iterator it=a.begin();it!=a.end();it++) cout&lt;&lt;*it&lt;&lt;&quot; &quot;; return 0;&#125;//结果为3 5 6 7 8 9 pair对组 pair只含有两个元素，可以看作是只有两个元素的结构体. 头文件 1#include&lt;utility&gt; 字符串 头文件 1#include &lt;string&gt; 初始化 12345678string str1; //生成空字符串string str2(&quot;123456789&quot;); //生成&quot;1234456789&quot;的复制品 string str3(&quot;12345&quot;, 0, 3);//结果为&quot;123&quot; ，从0位置开始，长度为3string str4(&quot;123456&quot;, 5); //结果为&quot;12345&quot; ，长度为5string str5(5, &#x27;2&#x27;); //结果为&quot;22222&quot; ,构造5个字符&#x27;2&#x27;连接而成的字符串string str6(str2, 2); //结果为&quot;3456789&quot;，截取第三个元素（2对应第三位）到最后 函数方法 函数 含义 sort(s.begin(),s.end()); 排序 size()length() 长度 max_size() 返回string对象最多包含的字符数 capacity() 重新分配内存之前，string对象能包含的最大字符数 push_back() 末尾插入 insert(pos,element) 插入 append(str) 末尾添加字符串 erase(it)erase(iterator p) 删除指定字符 erase(iterator first, iterator last) 删除字符串中迭代器区间所有字符 clear() 清空 replace(pos,n,str) 把当前字符串从索引pos开始的n个字符替换为str replace(pos,n,x,c) 把当前字符串从索引pos开始的n个字符替换为x个字符c replace(it1,it2,str) 把当前字符串[it1,it2)区间替换为str tolower() 转换为小写 toupper() 转换为大写 substr(pos,n) 截取从pos索引开始的n个字符 find (str, pos)find (c, pos) 在当前字符串的pos索引位置(默认为0)开始，查找子串str，返回找到的位置索引，-1表示查找不到子串 rfind (str, pos) 在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引 find_first_of (str, pos) 在当前字符串的pos索引位置(默认为0)开始，查找子串s的字符 .find_first_not_of (str,pos) 在当前字符串的pos索引位置(默认为0)开始，查找第一个不位于子串s的字符 find_last_of(str, pos) 当前字符串的pos索引位置开始，查找最后一个位于子串s的字符 find_last_not_of ( str, pos) 在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符 bitsei位组 头文件 1#include &lt;bitset&gt; 初始化 1234bitset &lt; n &gt;a; //a有n位，每位都为0bitset &lt; n &gt;a(b);bitset &lt; n &gt;a(s,pos,n);//a是s中从位置pos开始的n个位的副本bitset &lt; n &gt;a(s); 函数方法 函数 含义 any() 是否存在置为1的二进制位，有返回true none() b中是否没有1 count() 1的个数 size() 二进制位的个数 test(pos) 在pos位置是否为1，是返回true b.set() 所有位都置为1 reset() 所有位都置为0 reset(pos) pos位置置为0 flip() 所有二进制位取反 flip(pos) pos位置取反 to_ulong() 同样的二进制位返回一个unsigned long值 bitset也支持位运算 array数组 头文件 1#include &lt;array&gt; 初始化 1234array&lt;int, 100&gt; a;//声明一个大小为100的int型数组array&lt;int, 100&gt; a&#123;&#125;;//声明一个大小为100的int型数组，初始值均为0array&lt;int, 100&gt; a&#123;1, 2, 3&#125;;//始化部分值，其余全部为0array&lt;int, 100&gt; a = &#123;1, 2, 3&#125;; 访问遍历 12345678910111213array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;for(int i = 0; i &lt; 4; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; \\n&quot;[i == 3];//迭代器for(auto i : a) cout &lt;&lt; i &lt;&lt; &quot; &quot;;//at访问array&lt;int, 4&gt; a = &#123;1, 2, 3, 4&#125;;int res = a.at(1) + a.at(2);cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;;get&lt;1&gt;(a) = x;//将a数组下标为1位置处的值改为x 方法函数 函数 含义 begin() 第一个元素的访问迭代器 end() 返回容器最后一个元素之后一个位置的访问迭代器 rbegin() 返回最后一个元素的访问迭代器 rend() 返回第一个元素之前一个位置的访问迭代器 size() 返回容器中元素的数量 max_size() 返回容器可容纳元素的最大数量 empty() 判断容器是否为空 at(n) 返回容器中 n 位置处元素的引用 front() 返回容器中第一个元素的直接引用 back() 返回容器中最后一个元素的直接引用 data() 返回一个指向容器首个元素的指针 fill(x) 将 x 这个值赋值给容器中的每个元素,相当于初始化 array1.swap(array2) 交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型 sort() 排序 tuple元组 头文件 1#include &lt;tuple&gt; 初始化 1234567tuple&lt;int, int, string&gt; t1;//声明一个空的tuple三元组t1 = make_tuple(1, 1, &quot;hahaha&quot;);tuple&lt;int, int, int, int&gt; t2(1, 2, 3, 4);auto p = make_pair(&quot;wang&quot;, 1);tuple&lt;string, int&gt; t3 &#123;p&#125;; //将pair对象赋给tuple对象 操作 读取修改 12int first = get&lt;0&gt;(t);get&lt;0&gt;(t) = 1; 获取元素个数 12tuple&lt;int, int, int&gt; t(1, 2, 3);cout &lt;&lt; tuple_size&lt;decltype(t)&gt;::value &lt;&lt; &quot;\\n&quot;; // 3 解包 12345int one, three;string two; tuple&lt;int, string, int&gt; t(1, &quot;hahaha&quot;, 3);tie(one, two, three) = t;cout &lt;&lt; one &lt;&lt; two &lt;&lt; three &lt;&lt; &quot;\\n&quot;; // 1hahaha3","categories":[{"name":"C++","slug":"C","permalink":"http://www.mrharsh.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.mrharsh.top/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://www.mrharsh.top/tags/STL/"}]},{"title":"C++编程","slug":"C-编程","date":"2022-08-10T03:28:35.000Z","updated":"2022-08-10T03:34:26.204Z","comments":true,"path":"2022/08/10/C-编程/","link":"","permalink":"http://www.mrharsh.top/2022/08/10/C-%E7%BC%96%E7%A8%8B/","excerpt":"","text":"从C到C++ C是面向过程的语言，对于小规模程序还是得心应手的，为了程序设计的更见简易，C++最为C语言的自增版，保留原来语法，增加面向对象机制。","categories":[{"name":"C++","slug":"C","permalink":"http://www.mrharsh.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.mrharsh.top/tags/C/"},{"name":"OP编程","slug":"OP编程","permalink":"http://www.mrharsh.top/tags/OP%E7%BC%96%E7%A8%8B/"}]},{"title":"urllib库的使用","slug":"urllib库的使用","date":"2022-08-09T06:51:35.000Z","updated":"2022-08-10T03:25:24.669Z","comments":true,"path":"2022/08/09/urllib库的使用/","link":"","permalink":"http://www.mrharsh.top/2022/08/09/urllib%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"开始 urllib是Python内置的HTTP请求模块，其包含以下四个模块 request:HTTP请求模块 error:异常处理模块 parse:工具模块，拆分、解析、合并 robotparser:识别网站robots.txt文件，判断哪些网站可以爬。 请求发送 urlopen() 123456import urllib.requestresponse=urllib.request.urlopen(&#x27;https://www.baidu.com&#x27;)print(response.read().decode(&#x27;utf-8&#x27;))#read可以返回网页内容， 网页编码为UTF-8需要用decode,不然会有转义字符print(type(response)) #类型print(response.status) #获取响应状态码print(response.getheaders()) #获取响应头rs()) data参数 data参数为可选，使用需要，使用bytes()转换为字节流编码格式 12345import urllib.requestimport urllib.parsedata=bytes(urllib.parse.urlencode(&#123;&#x27;B&#x27;:&#x27;1&#x27;&#125;),encoding=&#x27;utf-8&#x27;)response=urllib.request.urlopen(&#x27;http://httpbin.org/post&#x27;,data=data)print(response.read().decode(&#x27;utf8&#x27;)) 我们的数据出现在了form字段里，这是我们用POST方法传递的数据 timeout参数 12345678import urllib.requestimport sockettry: response=urllib.request.urlopen(&#x27;http://www.google.com&#x27;,timeout=1) print(response.read().decode(&#x27;utf-8&#x27;))except urllib.error.URLError as e: if isinstance(e.reason,socket.timeout): print(&#x27;TIME OUT&#x27;) Request() Request能实现更多参数的请求 123def __init__(self, url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None): URL:请求URL data:必须为bytes(),如果是字典可以用urllib.parse.urlencode() headers:为一个字典 origin_req_host：表示这个请求是否是无法验证的 method:请求方法 123456789101112131415161718from urllib import request,parseurl=&#x27;http://httpbin.org/post&#x27;headers=&#123; &#x27;Host&#x27;:&#x27;httpbin.org&#x27;, &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36 Edg/104.0.1293.47&#x27;&#125;dict=&#123;&#x27;b&#x27;:1&#125;data=bytes(parse.urlencode(dict),encoding=&#x27;utf8&#x27;)data=bytes(parse.urlencode(&#123;&#x27;B&#x27;:&#x27;1&#x27;&#125;),encoding=&#x27;utf-8&#x27;)req=request.Request(url,data=data,headers=headers,method=&#x27;POST&#x27;)&quot;&quot;&quot;另一种请求头的添加方式req=request.Request(url=url,data=data,method=&#x27;POST&#x27;)req.add_header(&#x27;Host&#x27;,&#x27;httpbin.org&#x27;,)&quot;&quot;&quot;response=request.urlopen(req)print(response.read().deco 进阶用法 Handler 现在我们介绍Handler 比如： HTTPDefaultErrorHandler:用于处理","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.mrharsh.top/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.mrharsh.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.mrharsh.top/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"爬虫基础","slug":"爬虫基础","date":"2022-08-09T02:48:02.000Z","updated":"2022-08-09T05:36:50.356Z","comments":true,"path":"2022/08/09/爬虫基础/","link":"","permalink":"http://www.mrharsh.top/2022/08/09/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/","excerpt":"","text":"HTTP基本原理 参考资料： HTTP 教程 | 菜鸟教程 (runoob.com) URI和URL URI:统一资源标识符 URL:统一资源定位符 URN:统一资源名称 现在互联网，URN用得很少，一般网页链接🔗称为URL 超文本 网页源代码HTML称为超文本 HTTP和HTTPS HTTP:超文本传输协议 HTTPS:HTTP下加入SSL层 HTTP 请求过程 我们利用浏览器”检查“工具的网络来观察这个过程 General部分 Request URL:请求的URL Request Method:请求方法 Status Code: 响应状态码 Remote Address:远程服务器的地址和端口 Referrer Policy:Referrer判别策略 Response Header:响应头 Request Header:请求头 请求 请求由客户端发出，分为4部分 请求方法:Request Method 请求网址:Request URL 请求头:Request Headers 请求体:Request Body 请求方法 常见的为：GET和POST GET 与POST区别 GET的参数在URL里面，而POST请求的数据以表单传输，包含在请求体 GET的数据只有1024字节，而POST没有限制 其他请求方法 请求的网址 请求的网址即URL 请求头 Accept:请求报头域，指定客户端接收哪些类型的信息 Accept-Language:指定客户端可接受语言类型 Host:指定请求资源的主机IP和端口 Cookie:储存在用户本地终端上的数据,特定的 web文档关联在一起, 保存了该客户机访问这个Web 文档时的信息, 当客户机再次访问这个 Web 文档时这些信息可供该文档使用。 Referer:标识请求是从那个页面发过来的 User-Agent:一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。 Content-Type:内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定文件接收方将以什么形式、什么编码读取这个文件 请求体 请求体承载的是POST的表单数据，对于GET，请求为空 响应 响应状态码 常见的 HTTP 状态码： 200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误 其它可以参考HTTP 状态码 | 菜鸟教程 响应头 响应头包含服务器对请求的应答信息，如Content-Type、Sever、Set-Cookie 响应体 响应体包含响应的正文数据 网页基础 网页组成 网页是由HTML、CSS、JavaScript组成 如果想学爬虫，必须要点Web基础","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.mrharsh.top/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.mrharsh.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.mrharsh.top/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-08-07T17:38:10.230Z","updated":"2022-08-08T14:03:31.441Z","comments":true,"path":"2022/08/08/hello-world/","link":"","permalink":"http://www.mrharsh.top/2022/08/08/hello-world/","excerpt":"","text":"在Hexo上写文章 以前我是有写博客的用的是wordpress，wp可以说非常优秀，各种插件与主题，个性化也是非常的高，就是写博客就要有专门的时间写博客，而现在我发现hexo可以用markdown边写笔记，加个header就可以博客文章了，很方便！ Hello World 就让一句&quot;Hello world&quot;来开始新的旅程！","categories":[{"name":"随想","slug":"随想","permalink":"http://www.mrharsh.top/categories/%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"随想","slug":"随想","permalink":"http://www.mrharsh.top/tags/%E9%9A%8F%E6%83%B3/"}]}],"categories":[{"name":"刷题","slug":"刷题","permalink":"http://www.mrharsh.top/categories/%E5%88%B7%E9%A2%98/"},{"name":"C++","slug":"C","permalink":"http://www.mrharsh.top/categories/C/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.mrharsh.top/categories/%E7%88%AC%E8%99%AB/"},{"name":"随想","slug":"随想","permalink":"http://www.mrharsh.top/categories/%E9%9A%8F%E6%83%B3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.mrharsh.top/tags/C/"},{"name":"算法","slug":"算法","permalink":"http://www.mrharsh.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"STL","slug":"STL","permalink":"http://www.mrharsh.top/tags/STL/"},{"name":"OP编程","slug":"OP编程","permalink":"http://www.mrharsh.top/tags/OP%E7%BC%96%E7%A8%8B/"},{"name":"Python","slug":"Python","permalink":"http://www.mrharsh.top/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.mrharsh.top/tags/%E7%88%AC%E8%99%AB/"},{"name":"随想","slug":"随想","permalink":"http://www.mrharsh.top/tags/%E9%9A%8F%E6%83%B3/"}]}